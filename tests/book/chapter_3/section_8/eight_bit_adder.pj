/**
 * ProcessJ Book Code
 * Chapter 3
 * Section 8.1
 * Page 93
 */

import std.*;

public void notGate(chan<boolean>.read in, chan<boolean>.write out) {

    boolean x;
    x = in.read();
    out.write(!x);

}

public void orGate(chan<boolean>.read in1,
                   chan<boolean>.read in2,
                   chan<boolean>.write out) {

    boolean x, y;
    par {
        x = in1.read();
        y = in2.read();
    }
    out.write(x || y);

}

public void andGate(chan<boolean>.read in1,
                    chan<boolean>.read in2,
                    chan<boolean>.write out) {

    boolean x, y;
    par {
        x = in1.read();
        y = in2.read();
    }
    out.write(x && y);

}

public void nandGate(chan<boolean>.read in1,
                     chan<boolean>.read in2,
                     chan<boolean>.write out) {

    chan<boolean> a;
    par {
        andGate(in1, in2, a.write);
        notGate(a.read, out);
    }

}

public void deltaGate(chan<boolean>.read in,
                      chan<boolean>.write out1,
                      chan<boolean>.write out2) {

    boolean x;
    x = in.read();
    par {

        out1.write(x);
        out2.write(x);

    }

}

public void xorGate(chan<boolean>.read in1,
                    chan<boolean>.read in2,
                    chan<boolean>.write out) {

    chan<boolean> a, b, c, d, e, f, g, h, i;
    par {

        deltaGate(in1, a.write, b.write);
        deltaGate(in2, c.write, d.write);
        nandGate(b.read, c.read, e.write);
        deltaGate(e.read, f.write, g.write);
        nandGate(a.read, f.read, h.write);
        nandGate(d.read, g.read, i.write);
        nandGate(h.read, i.read, out);

    }

}

public void oneBitAdder(chan<boolean>.read in1,
                        chan<boolean>.read in2,
                        chan<boolean>.read carryIn,
                        chan<boolean>.write result,
                        chan<boolean>.write carryOut) {

    chan<boolean> a, b, c, d, e, f, g, h, i, j, k;
    par {
        deltaGate(in1, a.write, b.write);
        deltaGate(in2, c.write, d.write);
        xorGate(a.read, c.read, e.write);
        deltaGate(e.read, f.write, g.write);
        deltaGate(carryIn, h.write, i.write);
        xorGate(f.read, h.read, result);
        andGate(g.read, i.read, j.write);
        andGate(b.read, d.read, k.write);
        orGate(j.read, k.read, carryOut);
    }

}

public void fourBitAdder(chan<boolean>.read inA0,
                         chan<boolean>.read inA1,
                         chan<boolean>.read inA2,
                         chan<boolean>.read inA3,
                         chan<boolean>.read inB0,
                         chan<boolean>.read inB1,
                         chan<boolean>.read inB2,
                         chan<boolean>.read inB3,
                         chan<boolean>.read carryIn,
                         chan<boolean>.write result0,
                         chan<boolean>.write result1,
                         chan<boolean>.write result2,
                         chan<boolean>.write result3,
                         chan<boolean>.write carryOut) {

    chan<boolean> a, b, c;
    par {
        oneBitAdder(inA0, inB0, carryIn, result0, a.write);
        oneBitAdder(inA1, inB1, a.read, result1, b.write);
        oneBitAdder(inA2, inB2, b.read, result2, c.write);
        oneBitAdder(inA3, inB3, c.read, result3, carryOut);
    }

}


public void eightBitAdder(chan<boolean>.read inA0,
                          chan<boolean>.read inA1,
                          chan<boolean>.read inA2,
                          chan<boolean>.read inA3,
                          chan<boolean>.read inA4,
                          chan<boolean>.read inA5,
                          chan<boolean>.read inA6,
                          chan<boolean>.read inA7,
                          chan<boolean>.read inB0,
                          chan<boolean>.read inB1,
                          chan<boolean>.read inB2,
                          chan<boolean>.read inB3,
                          chan<boolean>.read inB4,
                          chan<boolean>.read inB5,
                          chan<boolean>.read inB6,
                          chan<boolean>.read inB7,
                          chan<boolean>.read carryIn,
                          chan<boolean>.write result0,
                          chan<boolean>.write result1,
                          chan<boolean>.write result2,
                          chan<boolean>.write result3,
                          chan<boolean>.write result4,
                          chan<boolean>.write result5,
                          chan<boolean>.write result6,
                          chan<boolean>.write result7,
                          chan<boolean>.write carryOut) {

    chan<boolean> a; 
    par {
        fourBitAdder(inA0, inA1, inA2, inA3,
                     inB0, inB1, inB2, inB3, carryIn,
                     result0, result1, result2, result3, a.write);
        fourBitAdder(inA4, inA5, inA6, inA7,
                     inB4, inB5, inB6, inB7, a.read,
                     result4, result5, result6, result7, carryOut);
    }

}


public string bitstringOf(int number, int length) {

    string result = "";

    for(int index = length - 1; index >= 0; index--) {

        int check = (number << 31);

        check >>= 31;

        if(check != 0) result = ("1" + result);

        else result = ("0" + result);

        number >>= 1;

    }

    return result;

}



public void main(string[] args) {

    chan<boolean> inA0, inA1, inA2, inA3, inA4, inA5, inA6, inA7;
    chan<boolean> inB0, inB1, inB2, inB3, inB4, inB5, inB6, inB7;
    chan<boolean> result0, result1, result2, result3;
    chan<boolean> result4, result5, result6, result7;
    chan<boolean> carryIn, carryOut;

    int bitwidth = 8;
    int range    = 127;

    for(int a = 0; a < range; a++)
        for(int b = 0; b < range; b++) {

            // Create the strings
            string string_a = bitstringOf(a, bitwidth);
            string string_b = bitstringOf(b, bitwidth);

            // Initialize the input
            boolean[] input_a = new boolean[bitwidth];
            boolean[] input_b = new boolean[bitwidth];
            boolean[] result  = new boolean[bitwidth];
            boolean   carry   = false;

            int number = a;

            for(int index = bitwidth - 1; index >= 0; index--) {

                int check = (number << 31);

                check >>= 31;

                if(check != 0) input_a[index] = true;

                else input_a[index] = false;

                number >>= 1;

            }

            number = b;

            for(int index = bitwidth - 1; index >= 0; index--) {

                int check = (number << 31); 

                check >>= 31;

                if(check != 0) input_b[index] = true; 

                else input_a[index] = false;

                number >>= 1;

            }

            par {

                inA0.write(input_a[0]);
                inA1.write(input_a[1]);
                inA2.write(input_a[2]);
                inA3.write(input_a[3]);
                inA4.write(input_a[4]);
                inA5.write(input_a[5]);
                inA6.write(input_a[6]);
                inA7.write(input_a[7]);


                inB0.write(input_b[0]);
                inB1.write(input_b[1]);
                inB2.write(input_b[2]);
                inB3.write(input_b[3]);
                inB4.write(input_b[4]);
                inB5.write(input_b[5]);
                inB6.write(input_b[6]);
                inB7.write(input_b[7]);

                carryIn.write(false);

                eightBitAdder(inA0.read, inA1.read, inA2.read, inA3.read,
                              inA4.read, inA5.read, inA6.read, inA7.read,
                              inB0.read, inB1.read, inB2.read, inB3.read,
                              inB4.read, inB5.read, inB6.read, inB7.read,
                              carryIn.read,
                              result0.write, result1.write, result2.write, result3.write,
                              result4.write, result5.write, result6.write, result7.write,
                              carryOut.write);

                result[0] = result0.read();
                result[1] = result1.read();
                result[2] = result2.read();
                result[3] = result3.read();
                result[4] = result4.read();
                result[5] = result5.read();
                result[6] = result6.read();
                result[7] = result7.read();

                carry = carryOut.read();

            }

            for(int index = 0; index < bitwidth; index++)
                if(result[index] == true) print("1");
                else print("0");

            println("");

        }

}
