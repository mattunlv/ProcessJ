/**
 * ProcessJ Book Code
 * Chapter 3
 * Section 7.3
 * Page 80-86
 */

import std.*;

public void id(chan<int>.read in, chan<int>.write out) {

    while (true) {

        int x;
        x = in.read();
        out.write(x);

    }

}

public void succ(chan<int>.read in, chan<int>.write out) {

    while (true) {

        int x;
        x = in.read();
        out.write(x + 1);
    }

}

public void blackHole(chan<int>.read in) {

    while (true) {

        int x;
        x = in.read();

    }

}

public void plus(chan<int>.read in1, chan<int>.read in2, chan<int>.write out) {

    while (true) {

        int x1, x2;

        par {

            x1 = in1.read();
            x2 = in2.read();

        }

        out.write(x1 + x2);

    }

}

public void delta(chan<int>.read in, chan<int>.write outl, chan<int>.write out2) {

    while (true) {

        int x;
        x = in.read();

        par {

            outl.write(x);
            out2.write(x);

        }

    }

}

public void prefix(const int n, chan<int>.read in, chan<int>.write out) {

    out.write (n);
    id(in, out);

}

public void tail(chan<int>.read in, chan<int>.write out) {

    int x;

    x = in.read();
    id(in, out);

}

public void FIFO6(chan<int>.read in, chan<int>.write out) {

    chan<int> c1, c2, c3, c4, c5;

    par {

        id(in, c1.write);
        id(c1.read, c2.write);
        id(c2.read, c3.write);
        id(c3.read, c4.write);
        id(c4.read, c5.write);
        id(c5.read, out);

    }

}

public void numbers(chan<int>.write out) {

    chan<int> a, b, c;

    par {

        delta(a.read, out, b.write);
        succ(b.read, c.write);
        prefix(0, c.read, a.write);

    }

}

public void integrate(chan<int>.read in, chan<int>.write out) {

    chan<int> a, b, c;

    par {

        delta(a.read, out, b.write);
        prefix(0, b.read, c.write);
        plus(in, c.read, a.write);

    }

}

public void fibonacci(chan<int>.write out) {

    chan<int> a, b, c, d;

    par {

        delta(a.read, b.write, out);
        pairs(b.read, c.write);
        prefix(0, d.read, a.write);
        prefix(1, c.read, d.write);

    }


}

public void pairs(chan<int>.read in, chan<int>.write out) {

    chan<int> a, b, c;

    par {

        delta(in, a.write, b.write);
        tail(a.read, b.write);
        plus(a.read, b.read, out);

    }

}

public void squares(chan<int>.write out) {

    chan<int> a, b;

    par {

        numbers(a.write);
        integrate(a.read, b.write);
        pairs(b.read, out);

    }

}

public void number_stream(chan<int>.write out, int count) {

    for(int number = 1; number <= count; number++) {

        println("Writing: " + number);
        out.write(number);

    }

}

public void print_next(chan<int>.read in) {

    while(true) {

        int result = in.read();

        println("Received: " + result);

    }

}

public void main(string[] args) {

    chan<int> a, b;

    int result;
    int count = 10;


    /// ------
    /// Test 1

    par {

        FIFO6(a.read, b.write);

        // A single write to the channel is fine, nothing illegal here
        a.write(45);

        result = b.read();

    }

    /// ------
    /// Test 2

    par {

        FIFO6(a.read, b.write);

        // Illegal; we shouldn't be writing to the same channel in a single par
        a.write(45);
        a.write(46);

        result = b.read();

    }

    /// ------
    /// Test 3

    par {

        // Works with a single write statement; i.e. same effect as Test 1.
        // Fails when additional write statements are included within the seq
        // block, same effect as placing additional illegal write statements
        seq {

            a.write(45);

        }

        FIFO6(a.read, b.write);
        result = b.read();

    }

    /// ------
    /// Test 4

    /// Similar to tests 3 & 2 but different output. Multiple reads required (illegal)
    par {

        print_next(b.read);

        FIFO6(a.read, b.write);

        number_stream(a.write, count);

    }

    println("[FIFO6]: Received " + result);

    /// ------
    /// Test 5

    /// Clearly illegal. Same effect as having a long par block
    par for(int number = 0; number < count; number++) {

        FIFO6(a.read, b.write);

        result = b.read();

        a.write(number);

    }

    /// ------
    /// Test 6

    for(int number = 0; number < count; number++) {

        par {

            FIFO6(a.read, b.write);
            result = b.read();
            a.write(number);

        }


        println("[FIFO6]: " + result);

    }

    /// ------
    /// Test 7

    chan<int> c, d;

    /// This will deadlock

    par {

        numbers(c.write);
        FIFO6(c.read, d.write);
        result = d.read();

    }

    /// ------
    /// Test 8

    // This will deadlock

    par {

        numbers(c.write);
        result = c.read();

    }

    /// ------
    /// Test 9

    // This will deadlock

    par {

        numbers(c.write);
        integrate(c.read, d.write);

        result = d.read();

        println("[Integrate]: " + result);

    }

    /// -------
    /// Test 10

    /// This will deadlock

    par {

        numbers(c.write);
        integrate(c.read, d.write);

        for(int number = 0; number < 100; number++) {

            result = d.read();

            println("[Integrate]: " + result);

        }

    }

    /// -------
    /// Test 11

    /// This will iterate through but will result in 0 when reading

    par {

        numbers(c.write);

        integrate(c.read, d.write);

        par for(int number = 0; number < 100; number++) {

            result = d.read();

            println("[Integrate]: " + result);

        }

    }

    /// -------
    /// Test 12

    /// this deadlocks

    for(int index = 0; index < 32; index++) {

        int result;

        par {

            c.write(index);
            pairs(c.read, d.write);
            result = d.read();

        }

        println("Result: " + result);

    }

    /// -------
    /// Test 13

    par {

        c.write(5);
        pairs(c.read, d.write);
        result = d.read();

    }

    par {

        FIFO6(a.read, b.write);
        number_stream(a.write, 100);
        print_next(b.read);

    }

}
