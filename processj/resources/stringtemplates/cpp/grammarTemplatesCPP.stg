delimiters "<",">"

Info() ::= <<
This file contains all of the templates for the ProcessJ compiler
based on the intermediate representation generated by the
CodeGeneratorCPP visitor.
>>

//========================================================================================
// Takes a ProcessJ file and turns it into a CPP file that can be run
// again and again while maintaining the logical structure of the code
// translated by the ProcessJ CPP compiler. The parameters below represent
// what gets pushed into the template, and, for now, these parameters
// generate the entire code for a compilable Java file.
// 1) pathName: A region that organizes a set of related types, procedures,
//              variables, etc.
// 2) filename: The name of a ProcessJ file.
// 3) name: The target class for the JVM.
// 4) body: A list of declarations generated from a ProcessJ source code.
// 5) imports: A list of import declarations.
//---
// needs to be finished: is this all we need? TODO: maybe the target c++ std
Compilation(pathName, fileName, name, body, version, imports) ::= <<
#include \<ProcessJRuntime.hpp>
#include \<functional>
<if(imports)><imports; separator="\n"><\n><endif>

/**
 * File generated by the ProcessJ Compiler.
 * Package name '<pathName>'.
 * Code generation for '<fileName>'.
 * Target class '<name>'.
 *
 * @author ProcessJ Group - University of Nevada, Las Vegas.
 */
<!class <name> {!>

<if(body)><body; separator="\n\n"><endif>
<!}!>
>>

//========================================================================================
// A main method definition that represents the entry point of every
// ProcessJ program and one that is called by the JVM when the program
// is run.
// 1) class: the name of the class from which a 'main' process
//           can be created and then called by the JVM.
// 2) name: an instance of an entry point of any ProcessJ program.
// 3) types: the type of values associated with formal parameters.
// 4) vars: the names of the formal parameters.
Main(class, name, types, vars, argc, argv) ::= <<
<! NOTE: since ProcessJ only ever has one argument in main (same rules as Java)
 ! we can simply add an argc, and rename argv to whatever the args are called
 ! by the ProcessJ internal naming convention
 !>
int main(int argc, char* argv[])
{
    std::cout \<\< "\n *** CREATING SCHEDULER *** \n\n";
    ProcessJRuntime::pj_scheduler sched;

    std::cout \<\< "\n *** CREATING MAIN PROCESS *** \n\n";
    <!<name>* main_proc = new <name>(argc, <vars; separator=", ">);!>
    <! TODO: need to account for arguments passed here... use a vector? !>

    ProcessJRuntime::pj_array\<std::string> args(argc);
    for(int i = 0; i \< argc; ++i)
    {
        args[i] = argv[i];
    }

    <name>* main_proc = new <name>(&sched, &args);

    std::cout \<\< "\n *** SCHEDULING MAIN PROCESS *** \n\n";
    sched.insert(main_proc);

    std::cout \<\< "\n *** STARTING SCHEDULER *** \n\n";
    sched.start();
}
>>

// TODO: finish up ProcClass below (don't need access
// specifiers in the decls, just static lifetime
// specifiers)
// also need a way to pass argv to proc$main...?
// it could be turned into a vector easily but
// then proc$main needs to have a ctor overloaded to
// accept a std::vector<T> of the args...
// need to flesh this out
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//========================================================================================
// Defines a class from which a process is created. This template
// represents the set of properties and methods that are common to
// all objects that extend the PJProcess class. The class declarations
// can include the following components, in order:
// 1) name: the name of the class preceded by '_proc'.
// 2) types: data types for formal parameters.
// 3) vars: unique names for fields preceded by '_pd'.
// 4) ltypes: data types for local parameters.
// 5) lvars: unique names for fields preceded by '_ld'.
// 6) methods: collection of statements that perform an operation.
// 7) main: the entry point of the program.
// 8) switchBlock: switch statement to jump through blocks to resume points.
// 9) syncBody: the body (content) of synchronized method that runs/starts a process.
// TODO: add altDecl/altSize to this
ProcClass(name, types, vars, ltypes, lvars, linits, ldeletes, lnulls, methods, main, switchBlock, syncBody, altLocals) ::= <<
class <name> : public ProcessJRuntime::pj_process
{

    <! TODO: this isn't right. need to fix class structure e.g. public, protected,
     ! private sections of code, destructor, etc.
     !>
    <! -------- Instance methods -------- !>
    <!<if(methods)><methods; separator="\n"><\n><endif>!>
    <! -------- Default Constructor -------- !>
    <!<name>(<types,vars:{t,v | <t> <v>}; separator=", ">) {!>
        <! Initialize member fields !>
        <!<if(vars)><vars:{v | this.<v> = <v>}; separator=";\n">;<endif>!>
    <!}!>
    <! TODO: this needs arguments as well... !>
public:

    <! -------- locals go here -------- !>
    <if(lvars)><ltypes,lvars:{t,v | <t> <v>}; separator=";\n">;<\n><endif>
    <if(altLocals)>
    std::vector\<bool> boolean_guards;
    std::vector\<ProcessJRuntime::AlternationGuardType> object_guards;
    bool alt_ready;
    int selected;
    <endif>

    <! -------- Constructors -------- !>
    <name>() = delete;
    <name>(ProcessJRuntime::pj_scheduler* sched<if(vars)>,<\n><\t><types,vars:{t,v | <t> <v>}; separator=",\n\t"><endif>)
    {
        this->sched = sched;
        <if(vars)>
        <vars:{v | this-><v> = <v>;}; separator="\n"><endif>

    }

    <! -------- Default Destructor -------- !>
    virtual ~<name>() = default;

    <! -------- Run Method -------- !>
    virtual void run()
    {
        <if(switchBlock)><switchBlock; separator="\n"><endif>
        <!<if(linits)><lvars,linits:{v,i | <v> = <i>}; separator=";\n">;<\n><endif>!>
        <if(syncBody)><syncBody; separator="\n"><endif>
        <if(lnulls)><lnulls; separator="\n"><endif>
        <if(ldeletes)><ldeletes; separator="\n"><endif>
        terminate();
        return;
    }

protected:
    <! -------- Instance variables for formal parameters -------- !>
    // formal variables
    <if(vars)><types,vars:{t,v | <t> <v>}; separator=";\n">;<endif>
<! every process has these 2 things in common, so just put them here !>
private:
    ProcessJRuntime::pj_scheduler* sched;
};
<! Entry point of the program, e.g.,
 ! void main(int argc, char* argv[]) { ... }
 !>
<if(main)><\n><\n><main><else><endif>
>>

//========================================================================================
// An simple (or normal) invocation consists of associating the caller
// with the parameters that are used to invoked it with. This will apply
// only to procedures that act and behave like any Java method (such methods
// are referred to by names and can be invoked at any point during the
// execution of the program) and ones that do not extend the class
// PJProcess.
// 1) name: the name of the invoked procedure.
// 2) vars: the names of the formal parameters.
Invocation(name, vars) ::= <<
<name>(<if(vars)><vars; separator=", "><endif>);
>>

//========================================================================================
//
// 1) name:
// 2) vars:
// 3) parBlock:
// 4) barrier:
InvocationProcType(name, vars, argvars, types, parBlock, barrier, anonCounter, parentClass, parent) ::= <<
<! TODO: how is this going to work? we don't support anonymous processes, and the
 ! closest we might get is passing lambdas as functions to finalize() or other
 ! necessarily-overloaded functions...
 ! ---
 ! The above is the plan (overloaded functions to take lambdas as well as a default)
 ! but this needs to be discussed with Pedersen first probably, I'm not sure what the
 ! heck to start doing for finalize. lambdas are possible, so are other things.
 ! ---
 ! this also passes the par, which is fine, but the proc itself doesn't account for
 ! the par in the args it expects... how to fix this?
 !>
 // THIS DOES NOT WORK WITH C++ (InvocationProcType)
<!(new <name>(<if(vars)><vars; separator=", "><endif>) {
    @Override
    public void finalize() {
        <parBlock>.decrement();
        <if(barrier)><barrier:{b | <b>.resign()}; separator=";\n">;<endif>
    }
}).schedule();!>
class <name>_overload_finalize_<anonCounter> : public <name>
{
public:
    <parentClass>* parent;

    <!<name>_overload_finalize_<anonCounter>(ProcessJRuntime::pj_scheduler* sched<if(barrier)>, ProcessJRuntime::pj_barrier* <barrier><endif>)
    : <name>{id, sched<if(barrier)>, <barrier><endif>}
    {

    }!>
    <name>_overload_finalize_<anonCounter>(ProcessJRuntime::pj_scheduler* sched<if(vars)>, <types,vars:{t,v | <t> <v>}; separator=", "><endif>, <parentClass>* parent)
    : <name>{sched<if(vars)>, <vars; separator=", "><endif>}, parent(parent)
    {
    }

    // my vars are <if(vars)><types,vars:{t,v | <t> <v>}; separator=", "><endif>
    virtual void finalize()
    {
        <if(parBlock)><if(parent)><parent><endif><parBlock>->decrement();<endif>
        <if(barrier)><barrier:{b | <if(parent)>parent-><endif><b>->resign()}; separator=";\n">;<endif>
    }
};
<!this->sched->insert(new <name>_overload_finalize(this->sched<if(barrier)>, <barrier><endif>));!>

this->sched->insert(new <name>_overload_finalize_<anonCounter>(this->sched<if(argvars)>, <argvars; separator=", "><endif>, this));
>>

//========================================================================================
// A method definition that specifies the types and names of parameters
// (which are separated by commas and enclosed in parenthesis and are
// required by methods during invocations), the access level such as
// 'public', 'private', or 'protected', the return value, a body between
// braces {}, and the name that uniquely identifies the method.
// 1) modifier: access level such as public, private, or protected.
// 2) type: the data type of the value returned by the method.
// 3) name: the name that uniquely applies and identifies the method.
// 4) types: the type of values associated to formal parameters.
// 5) vars: the names of the formal parameters preceded by '_ld'.
// 6) ltypes: data types for local parameters.
// 7) lvars: unique names for fields preceded by '_ld'.
// 8) body: the method body enclosed between braces.
Method(modifier, type, name, types, vars, ltypes, lvars, linits, ldeletes, body) ::= <<
<! TODO: this is fine for now... might not really be !>
static <type> <name>(<types,vars:{t,v | <t> <v>}; separator=", ">)
{
    <! -------- Variables for local parameters -------- !>
    <if(ltypes && lvars)><ltypes,lvars:{t,v | <t> <v>}; separator=";\n">;<\n><endif>
    <! The body may be an invocation or a sequence of statements !>
    <if(body)><body; separator="\n"><endif>
    <if(ldeletes)><ldeletes:{d | delete <d>}; separator=";\n">;<\n><endif>
}
>>

//========================================================================================
// A declaration for a member variable that is defined outside of
// any method but inside the class to which it belongs.
// 1) modifier: a keyword that defines the access of a field.
// 2) type: a data type that determines the value a variable can contain.
// 3) name: a qualified name for the member variable.
Field(modifier, type, name) ::= "<if(modifier)><modifier><else>public<endif> <type> <name>"

//========================================================================================
// Initializes a declaration for a variable given a type and a value.
// The declaration becomes a simple assignment statement if no type and
// no operator is specified. If a type is given, it becomes a new declaration
// in which a value may be assigned to the variable.
// 1) type: a data type that determines the value a variable can contain.
// 2) name: a qualified name for the variable.
// 3) val: the value to be assigned to the variable.
// 4) op: a build-in operator used to manipulate data and variables.
Var(type, name, val, op) ::= "<name><Init(val, op)>"
Type(type) ::= "<if(type)><type> <endif>"
Init(val, op) ::= "<if(val)> <if(op)><op><else>=<endif> <val>;<else>;<endif>"

//========================================================================================
// Defines a 'switch' block containing labels. These labels are used to
// route the flow of control to the resume points of different processes.
// 1) jumps: a list of cases generated by 'SwitchCase'.
SwitchBlock(jumps, name) ::= <<
<if(jumps)>
switch (get_label())
{
    case 0: goto <name>L0; break;
    <jumps; separator="\n">
}

<name>L0:
<endif>
>>

//========================================================================================
// Defines a statement in a 'switch' block with one case. The
// case evaluates to a label representing the resume point of
// a process.
// 1) jump: the label to restart from.
// TODO: this needs to be a goto somehow
SwitchCase(name, jump) ::= "case <jump>: goto <name>L<jump>; break;"

//========================================================================================
// Initializes a declaration for a 'par' statement (an object of type PJPar)
// defined in a process (an object of type PJProcess). This 'par' statement
// becomes a variable of the process in which it is declared. A reference
// to the process in which the 'par' appears and the number of processes
// found in the 'par' block are used to create a PJPar instance.
// 1) name: the name that uniquely applies and identifies the 'par' block.
// 2) count: the number of processes to run concurrently.
// 3) process: the reference to the process in which the 'par' block is defined.
// 4) body: the statements inside the 'par' block.
// 5) jump: the label to restart from.
// 6) barrier:
ParBlock(name, count, process, body, jump, barrier, enrollees, procName, parent) ::= <<

<! TODO: is this where the first label should go? !>
<!<procName>L0:!>
<! TODO: yet to be evaluated and adjusted !>
<if(parent)><parent><endif><name> = new ProcessJRuntime::pj_par(<count>, this);
<if(barrier)><barrier,enrollees:{b,e | <b>->enroll(<e>)}; separator=";\n">;<endif>

<if(body)><body; separator="\n\n"><endif>

<! Not to be scheduled again until 'data' is ready !>
if (<if(parent)><parent><endif><name>->should_yield()) {
    this->set_label(<jump>);
    return;
}</n>

<procName>L<jump>:
delete <if(parent)><parent><endif><name>;
>>

//========================================================================================
// Defines an anonymous process which consist of a switch block that
// contains jump labels for resumption and yield, a synchronized body
// that runs all the statements declared inside the procedure, and a
// 'par' block defined in a procedure. Note that the process's schedule()
// method is excluded iff it is created inside a par-for. If this is
// case, then we generated code similar to that of a ProcessClass; e.g.,
// with member fields.
// 1) switchBlock: switch statement to jump through blocks to resume points.
// 2) syncBody: the body (content) of synchronized method that runs/starts a process.
// 3) parBlock:
// 4) barrier:
// 5) ltypes: data types for local parameters that are used in a 'par-for'.
// 6) lvars: unique names for fields preceded by '_ld' that are used in a 'par-for'.
// 7) name: the name of the anonymous process generated by the compiler
AnonymousProcess(switchBlock, syncBody, parBlock, barrier, ltypes, lvars, name, anonCounter, chan, chanType, chanInnerType, types, vars, parentClass, parent, inPar) ::= <<
// my parent class is <parentClass>
// my locals are <if(ltypes && lvars)><ltypes,lvars:{t,v | <t> <v>}; separator=", "><endif>
class <name> : public ProcessJRuntime::pj_process
{
public:
    <parentClass>* parent;

    <name>() = delete;
    <name>(ProcessJRuntime::pj_scheduler* sched<if(types && vars)>,<\n><\t><types,vars:{t,v | <t> <v>}; separator=",\n"><endif>,
<\t><parentClass>* parent<if(ltypes && lvars)>,<\n><ltypes,lvars:{t,v | <t> <v>}; separator=",\n"><endif>)
    {
        this->sched = sched;
        this->parent = parent;
        <if(types && vars)>
        <vars:{v | this-><v> = <v>;}; separator="\n"><endif>
        <if(ltypes && lvars)>
        <lvars:{v | this-><v> = <v>;}; separator="\n"><endif>

    }

    <! virtual destructor !>
    virtual ~<name>() = default;

    <! Synchronized run method !>
    virtual void run()
    {
        <if(switchBlock)><switchBlock; separator="\n"><endif>
        <if(syncBody)><syncBody; separator="\n"><endif>
        terminate();
    }
    <! Finalize method !>
    virtual void finalize()
    {
        <if(parBlock)><if(parent)><parent><endif><parBlock>->decrement();<endif>
        <if(barrier)><barrier:{b | <if(parent)>parent-><endif><b>->resign()}; separator=";\n">;<endif>

    }
protected:
    <if(types && vars)><types,vars:{t,v | <t> <v>;}; separator="\n"><endif>
    <if(ltypes && lvars)><ltypes,lvars:{t,v | <t> <v>;}; separator="\n"><endif>

private:
    ProcessJRuntime::pj_scheduler* sched;
};

<if(!inPar)>this->sched->insert(new <name>(this->sched<if(vars)>, <vars; separator=", "><endif>, this));<endif>
>>

//========================================================================================
//
// 1) type:
ChannelDecl(type) ::= "<if(type)>new <type>()<endif>"

//========================================================================================
//
// 1) count:
BarrierDecl(count) ::= "new ProcessJRuntime::pj_barrier(<if(count)><count><endif>)"

// TODO: might not need this...
//ParDecl(count) ::= <<
//ProcessJRuntime::pj_par* <name> = new ProcessJRuntime::pj_par(<count>, this);
//>>

//========================================================================================
//
// 1) name:
TimerRedExpr(name) ::= "<name> = ProcessJRuntime::pj_timer::read();"

//========================================================================================
//
// 1) value:
// 2) type:
PrimitiveLiteral(value, type) ::= "<value><if(type)><type><endif>"

//========================================================================================
//
// 1) name:
// 2) type:
// 3) dims:
// 4) vals:
NewArray(name, type, init) ::= <<
new <type><init>;
>>

//========================================================================================
// 1) dims:
// 2) vals:
NewArrayLiteral(dims, vals, dim) ::= <<
<if(dims)><dims:{dim | [<dim>]}; separator = ""><else>{ <vals:{v | <v>}; separator=","> }<endif>
>>

//========================================================================================
//
// 1) name:
// 2) index:
ArrayAccessExpr(name, index) ::= "(*<name>)[<index>]"

//========================================================================================
//
// 1) name:
// 2) delay:
// 3) resume0:
TimeoutStat(name, delay, resume0, procName) ::= <<
<!<name> = new PJTimer(this, <delay>);!>
<name> = new ProcessJRuntime::pj_timer(this, <delay>);
<name>->set_process(this);
<name>->timeout(<delay>);
<name>->start();
this->sched->insert(<name>);
this->set_not_ready();
this->set_label(<resume0>);
// yield();
return;

<procName>L<resume0>:
>>

//========================================================================================
//
// 1.) name:
// 2.) delay:
TimeoutStatCase(name, delay) ::= <<
<name> = new ProcessJRuntime::pj_timer(this, <delay>);
>>

//========================================================================================
//
// 1) chaName: name of the write channel-end.
// 2) resume0:
// 3) resume1:
ChanWriteStat(chanName, writeExpr, procName, resume0) ::= <<
<chanName>->write(this, <writeExpr>);
this->set_label(<resume0>);
// yield();
return;

<procName>L<resume0>:
>>

//========================================================================================
//
// 1) chaName: name of the write channel-end.
// 2) resume0:
// 3) resume1:
ChannelReadExpr(chanName, lhs, op, procName, resume0, resume1, extendRv) ::= <<
// i'm a channel read, and my procName is <procName>
if (!<chanName>->is_ready_to_read(this)) {
    this->set_label(<resume0>);
    // yield();
    return;
}

<procName>L<resume0>:
<if(extendRv)> // Do we have a rendezvous?
<lhs> <op> <chanName>->pre_read_rendezvous(this);
<extendRv>
<chanName>->post_read_rendezvous(this);
<else>
<if(lhs)><lhs> <op> <chanName>->read(this);
<else><chanName>->read(this);
<endif>
<endif>

<!this->set_label(<resume1>);!>
<!// yield();!>
<!return;!>

<procName>L<resume1>:<!-- remove 'line-feed' --!>
>>

//========================================================================================
//
// 1) chanName:
// 2) resume0:
// 3) resume1:
// 4) resume2:
ChannelOne2Many(chanName, procName, lhs, op, resume0, resume1, resume2, extendRv) ::= <<
// if (!<chanName>.claimRead(this)) {
//     this.runLabel = <resume0>;
//     yield();
// }
// label(<resume0>);

// if (!<chanName>.isReadyToRead(this)) {
//     this.runLabel = <resume1>;
//     yield();
// }

// label(<resume1>);
// <if(extendRv)> // Do we have a rendezvous?
// <lhs> <op> <chanName>.preReadRendezvous(this);
// <extendRv>
// <chanName>.postReadRendezvous(this);
// <else>
// <if(lhs)><lhs> <op> <chanName>.read(this);
// <else><chanName>.read(this);
// <endif>
// <endif>
// this.runLabel = <resume2>;

// <chanName>.unclaimRead();

// yield();

if(!<chanName>->claim_read(this))
{
    set_label(<resume0>);
    // yield();
    return;
}

<procName>L<resume0>:
if(!<chanName>->is_ready_to_read(this))
{
    set_label(<resume1>);
    // yield();
    return;
}

<procName>L<resume1>:
<if(extendRv)> // Do we have a rendezvous?
<lhs> <op> <chanName>->pre_read_rendezvous(this);
<extendRv>
<chanName>->postReadRendezvous(this);
<else>
<if(lhs)><lhs> <op> <chanName>->read(this);
<else><chanName>->read(this);
<endif>
<endif>
set_label(<resume2>);

<chanName>->unclaim_read();
// yield();
return;
<procName>L<resume2>:
>>

//========================================================================================
//
// 1) chanName:
// 2) writeExpr:
// 3) resume0:
// 4) resume1:
ChannelMany2One(chanName, writeExpr, procName, resume0, resume1) ::= <<
// if (!<chanName>.claimWrite(this)) {
//     this.runLabel = <resume0>;
//     yield();
// }
// label(<resume0>);

// <chanName>.write(this, <writeExpr>);
// this.runLabel = <resume1>;

// yield();
// label(<resume1>);

// <chanName>.unclaimWrite();<\n>

if(!<chanName>->claim_write(this))
{
    set_label(<resume0>);
    // yield();
    return;
}
<procName>L<resume0>:

<chanName>->write(this, <writeExpr>);
set_label(<resume1>);
// yield();
return;

<procName>L<resume1>:
<chanName>->unclaim_write();<\n>
>>

//========================================================================================
//
// 1) expr:
// 2) thenPart:
// 3) elsePart:
IfStat(expr, thenPart, elsePart) ::= <<
if (<expr>) {
    <thenPart; separator="\n">
    (void)0; <! avoid dangling label in if !>
}<if(elsePart)> else {
    <elsePart; separator="\n">
    (void)0; <! avoid dangling label in else !>
}<endif>
>>

//========================================================================================
//
// 1) name:
BreakStat(name) ::= <<
<if(name)><name><else>break;<endif>
>>

//========================================================================================
//
// 1) label:
SwitchLabel(label, tag) ::= <<
<if(label)>case <label><else>default<endif>
>>

//========================================================================================
//
// 1) labels:
// 2) stats:
SwitchGroup(labels, stats) ::= <<
<labels:{l | <l>:}; separator="\n">
    <stats; separator="\n">
>>

//========================================================================================
//
// 1) expr:
// 2) block:
SwitchStat(expr, block, tag) ::= <<
switch(<expr><if(tag)>->tag<endif>) {
<block; separator="\n">
}
>>

//========================================================================================
//
// 1) operand:
// 2) op:
UnaryPostExpr(operand, op) ::= "<if(operand)><operand><op><endif>;"

//========================================================================================
//
// 1) operand:
// 2) op:
UnaryPreExpr(operand, op) ::= "<if(operand)><op><operand><endif>;"

//========================================================================================
//
// 1) type:
// 2) expr:
CastExpr(type, expr) ::= "<if(type)>((<type>) (<expr>))<endif>"

//========================================================================================
//
// 1) lhs:
// 2) rhs:
// 3) op:
BinaryExpr(lhs, rhs, op) ::= <<
<lhs> <op> <rhs>
>>

//========================================================================================
//
// 1) package:
// 2) file
// TODO: still need to figure this guy out
Import(package, file) ::= "#include \<<package><if(file)>/<file><endif>>"

//========================================================================================
//
// 1) modifier: access level such as public, private, or protected.
// 2) name: the name that uniquely applies and identifies the record.
// 3) types:
// 4) vars:
RecordClass(modifiers, name, types, vars) ::= <<
<if(modifiers)><modifiers; separator=" "> <else>protected <endif>static class <name> implements PJRecord {
    <! -------- Member variables -------- !>
    <if(vars)><types,vars:{t,v | public <t> <v>}; separator=";\n">;<\n><endif>
    <! -------- Default Constructor -------- !>
    public <name>(<types,vars:{t,v | <t> <v>}; separator=", ">) {
        <! Initialize member fields !>
        <if(vars)><vars:{v | this.<v> = <v>}; separator=";\n">;<endif>
    }
}
>>

RecordStruct(modifiers, name, extend, types, vars, deletes) ::= <<
<if(extend)>// extends records <extend:{e | <e>}; separator=", "><endif>
<if(extend)>struct <name> : <extend:{e | public <e>}; separator=", "><else>struct <name> : public ProcessJRuntime::pj_record<endif>
{
public:
    <name>() = default;
    <name>(<types,vars:{t,v | <t> <v>}; separator=", ">)
    {
        <if(vars)><vars:{v | this-><v> = <v>}; separator=";\n">;<endif>
    }

    ~<name>()
    {
        <! destructor should delete any pointer variables !>
        <if(deletes)><deletes:{d | delete <d>}; separator="\n">;<endif>
    }
    <if(vars)><types,vars:{t,v | <t> <v>}; separator=";\n">;<\n><endif>
};
>>

//========================================================================================
//
// 1) type:
// 2) vals:
RecordLiteral(type, names, vals) ::= <<
new <type> {<names,vals:{n,v | .<n> = <v>}; separator=", ">}
>>

//========================================================================================
//
// 1) name:
// 2) member:
RecordAccess(name, op, member) ::= "<if(name)><name><op><member><endif>"

//========================================================================================
//
// 1) modifier: access level such as public, private, or protected.
// 2) name: the name that uniquely applies and identifies the protocol.
// 3) body:
ProtocolClass(cases, name, body) ::= <<
<!<if(modifiers)><modifiers; separator=" "> <else>protected <endif>static class <name> {
    <body; separator="\n\n">
}!>

class <name>
{
public:
    <body; separator="\n\n">
};

>>

//========================================================================================
//
// 1) modifier:
// 2) name:
// 3) types:
// 4) vars:
ProtocolCaseOld(modifier, name, types, vars) ::= <<
<if(modifier)><modifier> <else>protected <endif>static class <name> extends PJProtocolCase {
    <! -------- Member variables -------- !>
    <if(vars)><types,vars:{t,v | public <t> <v>}; separator=";\n">;<\n><endif>
    <! -------- Default Constructor -------- !>
    public <name>(<types,vars:{t,v | <t> <v>}; separator=", ">) {
        <! Initialize member fields !>
        <if(vars)><vars:{v | this.<v> = <v>}; separator=";\n">;<endif>
        this.tag = "<name>";
    }
}
>>

ProtocolCase(modifier, name, types, vars, index) ::= <<
class <name> : public ProcessJRuntime::pj_protocol_case
{
public:
    <if(vars)><types,vars:{t,v | <t> <v>;}; separator="\n"><endif>

    <name>(<if(vars)><types,vars:{t,v | <t> <v>}; separator=", "><endif>)
    {
        <if(vars)><vars:{v | this-><v> = <v>;}; separator="\n"><endif>
        this->tag = <index>;
    }
};
>>

//========================================================================================
//
// 1) name:
// 2) tag:
// 3) vals:
ProtocolLiteral(type, protocolType, tag, vals) ::= <<
new <protocolType>::<tag>(<if(vals)><vals; separator=", "><endif>)
>>

//========================================================================================
//
// 1) protocName:
// 2) tag:
// 3) var:
// 4) member:
ProtocolAccess(protocName, tag, var, member) ::= <<
<!<if(protocName)>std::get\<<tag>*>(<var>)-><member><endif>!>
<if(protocName)>reinterpret_cast\<<protocName>::<tag>*>(<var>)-><member><endif>
>>

//========================================================================================
// TODO: this needs the proc name to build the label correctly
// 1) barrier:
// 2) resume0:
SyncStat(barrier, resume0, procName) ::= <<
<barrier>->sync(this);
this->set_label(<resume0>);
// yield();
return;
<!label(<resume0>);!>
<procName>L<resume0>:
>>

//========================================================================================
//
// 1) expr:
// 2) body:
WhileStat(expr, body, negexpr) ::= <<
while (<expr>) {
    <if(body)><body; separator="\n"><endif>
    (void)0; <! avoid dangling label at end of loop !>
}
>>

//========================================================================================
//
// 1) expr:
// 2) stats:
DoStat(expr, body) ::= <<
do {
    <if(body)><body; separator="\n"><endif>
    (void)0; <! avoid dangling label at end of loop !>
} while (<expr>);
>>

//========================================================================================
//
// 1) init:
// 2) expr:
// 3) incr:
// 4) stats:
ForStat(init, expr, incr, stats) ::= <<
for (<if(init)><init; separator=", "><else>/* ... */<endif>; <!--!><if(expr)><expr><else>/* ... */<endif>; <!--!><if(incr)><incr; separator=", "><else>/* ... */<endif>) {
     <stats; separator="\n">
     (void)0; <! avoid dangling label at end of loop !>
}
>>

//========================================================================================
//
// 1.) init:
// 2.) expr:
// 3.) incr:
// 4.) stats:
// 5.) name:
// 6.) count:
// 7.) jump:
// 8.) barrier:
ParForStat(init, expr, incr, stats, name, jump, barrier) ::= <<
<!
// final PJPar <name> = new PJPar(0, this);
// ArrayList\<PJProcess> processes = new ArrayList\<PJProcess>();
// int count = 0;

// for (<init>; <expr>; <incr>) {
//     ++count;
//     <stats:{st | processes.add(<st>)}; separator=";\n">;
// }

// <name>.setProcessCount(count);
// <if(barrier)><barrier:{b | <b>.enroll(count)}; separator=";\n">;<endif>

// for (PJProcess p : processes)
//     p.schedule();

// this.setNotReady();
// this.runLabel = <jump>;
// this.yield();
// label(<jump>);
!>

<name> = new ProcessJRuntime::pj_par(0, this);

for (<init>; <expr>; <incr>) {
    <stats:{st | <st>}; separator=";\n">;
}

<name>->set_process_count(0);
<if(barrier)><barrier:{b | <b>->enroll(0)}; separator=";\n">;<endif>

set_not_ready();
set_label(<jump>);
return;

//PROCNAMELJUMP
>>

//========================================================================================
//
// 1) number:
// 2) guardExpr:
// 3) stats:
AltCase(number, guardExpr, stats) ::= <<
case <number>:
    <guardExpr>
    <if(stats)><stats; separator="\n"><endif>
    break;
>>

//========================================================================================
//
// 1) alt:
// 2) count:
// 3) initBooleanGuards:
// 4) initGuards:
// 5) bguards:
// 6) guards:
// 7) jump:
// 8) cases:
// 9) index:
AltStat(alt, count, initBooleanGuards, initGuards, procName, jump, cases, index, timerLocals) ::= <<
<alt> = new ProcessJRuntime::Alternation(<count>, this);
<timerLocals>
boolean_guards = <initBooleanGuards>;
object_guards = <initGuards>;
alt_ready = <alt>->set_guards(boolean_guards, object_guards);
selected = static_cast\<int>(0);
<index> = static_cast\<int>(0);

if (!alt_ready) {
    std::cout \<\< "RuntimeError: One of the boolean pre-guards must be true!" \<\< std::endl;
    abort();
}

this->set_not_ready();
<index> = <alt>->enable();
this->set_label(<jump>);
// yield();
return;

<procName>L<jump>:
selected = <alt>->disable(<index>);

switch(selected)
{
    <cases; separator="\n">
    default:
        break;
}
delete <alt>;
>>

//========================================================================================
//
// 1) locals:
// 2) constants:
BooleanGuards(locals, constants) ::= <<
<if(locals)><locals; separator="\n"><endif>
<if(constants)>{ <constants; separator=", "> }<endif>
>>

//========================================================================================
//
// 1) guards:
ObjectGuards(guards) ::= <<
<if(guards)>{ <guards; separator=", "> }<endif>
>>

//========================================================================================
//
// 1) type:
// 2) var:
ConstantDecl(type, var) ::= "static const <type> <var>"

//========================================================================================
//
// 1) expr:
ReturnStat(expr) ::= "<if(expr)>return <expr>;<endif>"

//========================================================================================
// 1) name:
ContinueStat(name) ::= "<if(name)>continue <name><else>continue<endif>;"

//========================================================================================
//
InvocationIgnore(name, var) ::= "<name>(<var>);"
