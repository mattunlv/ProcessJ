package org.processj.compiler.utilities;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.Iterator;
import java.util.Stack;

/**
 * This class is used to track down various kinds of error/warning
 * messages produced by the ProcessJ compiler at compile-time.
 * 
 * @author ben
 * @version 21/10/2018
 * @since 1.2
 */
public enum PJBugManager {
    
    INSTANCE;
    
    private static final String OUTFILE_NAME = "PJErrorfile";
    
    /** Number of errors messages generated by the compiler */
    private int errorNum;
    
    /** Number of warning messages generated by the compiler */
    private int warningNum;
    
    /** Number of info messages generated by the compiler */
    private int infoNum;
    
    /** Last registered message */
    private PJMessage postPonedMessage = null;
    
    /** List of errors/warning messages */
    private Stack<PJMessage> trace;
    
    /** Input file that contains error/warning messages */
    private String fileName = "";
    
    /** Location of input file */
    private String packageName = "";
    
    PJBugManager() {
        errorNum = 0;
        trace = new Stack<>();
    }

    public static void ReportMessageAndExit(final Object... arguments) {

        INSTANCE.reportMessageAndExit(new PJMessage.Builder().addArguments(arguments).build(), PJMessage.MessageType.PRINT_STOP);

    }

    public void reportMessageAndExit(PJMessage bug, PJMessage.MessageType type) {
        assert bug != null;
        boolean stop = false;
        if (bug.getMessageNumber() != null) {
            PJMessage.ErrorSeverity severity = bug.getMessageNumber().getErrorSeverity();
            switch (severity) {
                case INFO:
                    ++infoNum;
                case WARNING:
                    ++warningNum;
                    break;
                case ERROR:
                    ++errorNum;
                    break;
            }
        } else
            ++errorNum;
        trace.push(bug);
        switch(type) {
        case PRINT_STOP:
            stop = true;
        case PRINT_CONTINUE:
            // Throw the first error that occurred
            if (postPonedMessage == null)
                postPonedMessage = bug;
            System.out.println(bug.getRenderedMessage());
            if(stop)
                System.exit(1);
        case DONT_PRINT_CONTINUE:
            break;
        }
    }

    public void reportErrorAndExitWithUsage(PJMessage bug, PJMessage.MessageType type) {
        assert bug != null;
        boolean stop = false;
        if (bug.getMessageNumber() != null) {
            PJMessage.ErrorSeverity severity = bug.getMessageNumber().getErrorSeverity();
            switch (severity) {
                case INFO:
                    ++infoNum;
                case WARNING:
                    ++warningNum;
                    break;
                case ERROR:
                    ++errorNum;
                    break;
            }
        } else
            ++errorNum;
        trace.push(bug);
        switch(type) {
            case PRINT_STOP:
                stop = true;
            case PRINT_CONTINUE:
                // Throw the first error that occurred
                if (postPonedMessage == null)
                    postPonedMessage = bug;
                System.out.println(bug.getRenderedMessage());
                if(stop) {

                    System.exit(1);

                }

            case DONT_PRINT_CONTINUE:
                break;
        }
    }

    public void reportMessage(PJMessage bug) {
        PJMessage.MessageType type = PJMessage.MessageType.PRINT_STOP;
        if (bug.getMessageNumber() != null)
            type = bug.getMessageNumber().getMessageType();
        reportMessageAndExit(bug, type);
    }

    public void printTrace(String src) {
        System.out.println("The application panicked! (crashed).");
        System.out.println("Location: " + src);
        System.out.println("Message:");
        String line = "-".repeat(30);
        String header = line + " BACKTRACE " + line;
        System.out.println(header);
        System.out.println("| (" + errorNum + " post panic error messages)");
        System.out.println("| (" + warningNum + " post warning messages)");
        System.out.println("| (" + infoNum + " post info messages)");
        System.out.println("...");
        Iterator<PJMessage> it = trace.iterator();
        while (it.hasNext()) {
            System.out.println(it.next().getRenderedMessage());
            if (it.hasNext())
                System.out.println("...");
        }
    }
    
    public String getFileName() {
        return fileName;
    }
    
    public String getPackageName() {
        return packageName;
    }

    public void writeBugsToFile(String dir) {
        // Write to current directory if none is provided
        if (dir == null || "".equals(dir))
            dir = new File("").getAbsolutePath() + File.separator;
        String outfile = dir + OUTFILE_NAME + ".txt";
        StringBuilder sb = new StringBuilder();
        for (PJMessage msg : trace) {
            sb.append(msg.getMessageNumber().getNumber());
            sb.append("\n");
        }
        Writer writer = null;
        try {
            writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outfile), "utf-8"));
            writer.write(sb.toString());
            writer.close();
        } catch (Exception e) {
            System.out.println(e);
        }
    }

}
