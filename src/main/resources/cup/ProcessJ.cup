/**
 * <p>ProcessJ Grammar.</p>
 * <p>This grammar defines the specification for ProcessJ source code.</p>
 * @author Jan B. Pedersen
 * @author Cabel Shrestha
 * @author Benjamin Cisneros
 * @author Carlos L. Cuenca
 * @version %I%, %G%
 * @since 0.1.0
 */

/** --------------------------------------------------------------------------------------------------------------- **/
/** Package Declaration                                                                                             **/
/** --------------------------------------------------------------------------------------------------------------- **/

package org.processj.compiler.phase.generated;

/** --------------------------------------------------------------------------------------------------------------- **/
/** Imports                                                                                                         **/
/** --------------------------------------------------------------------------------------------------------------- **/

import org.processj.compiler.ast.*;
import org.processj.compiler.ast.expression.*;
import org.processj.compiler.ast.expression.access.*;
import org.processj.compiler.ast.expression.binary.*;
import org.processj.compiler.ast.expression.constructing.*;
import org.processj.compiler.ast.expression.literal.*;
import org.processj.compiler.ast.expression.resolve.*;
import org.processj.compiler.ast.expression.result.*;
import org.processj.compiler.ast.expression.unary.*;
import org.processj.compiler.ast.expression.yielding.*;
import org.processj.compiler.ast.statement.*;
import org.processj.compiler.ast.statement.conditional.*;
import org.processj.compiler.ast.statement.control.*;
import org.processj.compiler.ast.statement.declarative.*;
import org.processj.compiler.ast.statement.yielding.*;
import org.processj.compiler.ast.type.*;
import org.processj.compiler.ast.modifier.*;

import java.io.FileReader;

/** --------------------------------------------------------------------------------------------------------------- **/
/** Scanning Method                                                                                                 **/
/** --------------------------------------------------------------------------------------------------------------- **/

scan with {:

    return lexer.next_token();

:};

/** --------------------------------------------------------------------------------------------------------------- **/
/** Lexer Initialization Code                                                                                       **/
/** --------------------------------------------------------------------------------------------------------------- **/

init with {: :}

/** --------------------------------------------------------------------------------------------------------------- **/
/** Parser Method & Variable Declarations                                                                           **/
/** --------------------------------------------------------------------------------------------------------------- **/

parser code {:

    public  Lexer   lexer   ;
    private Handler handler ;

    public Parser(final FileReader fileReader, final Handler handler) {
        this();

        this.lexer      = new Lexer(fileReader) ;
        this.handler    = handler               ;

    }

    public void syntax_error(java_cup.runtime.Symbol current) {

        // Delegate this to the Handler
        this.handler.onSyntaxError((Token) current.value,
            Lexer.LineCount, Lexer.CurrentLine.length() + 1, Lexer.LineCount);

    }

    public interface Handler {

        void onSyntaxError(final Token token, final int line, final int lineLength, final int lineCount);

        void onIllegalCastExpression(final Expression expression, final int lineLength, final int lineCount);

        void onMalformedPackageAccessExpression(final Expression expression, final int lineLength, final int lineCount);

    }

    public final Compilation getParsedCompilation() throws Exception {

        return (Compilation) this.parse().value;

    }


:};

/** --------------------------------------------------------------------------------------------------------------- **/
/** Action Code                                                                                                     **/
/** --------------------------------------------------------------------------------------------------------------- **/

action code {:

    // Converts a name or a nested record access expression to a package access
    public Sequence<Name> primary2PackageAccess(final Expression expression) {

        // Initialize a handle to the result
        Sequence<Name> result = null;

        if(expression instanceof RecordAccessExpression) {

            // Initialize a handle to the RecordAccessExpression
            final RecordAccessExpression recordAccessExpression = (RecordAccessExpression) expression;

            // Take the last (field) name off the record access and call recursively on the rest-
            // turn all into a sequence of names
            result = primary2PackageAccess(recordAccessExpression.getTarget()).append(recordAccessExpression.field());

        } else if(expression instanceof NameExpression) {

            // A name is OK - just turn it into a sequence with one member
            result = new Sequence<Name>(((NameExpression) expression).getName());

        } else {

            // Only a record access looks like a package access - everything else should produce an error
            handler.onMalformedPackageAccessExpression(expression,
                Lexer.CurrentLine.length() + 1, Lexer.LineCount);

        }

        // Finally, return the result
        return result;

    }

:}

/** --------------------------------------------------------------------------------------------------------------- **/
/** Terminals                                                                                                       **/
/** --------------------------------------------------------------------------------------------------------------- **/

/** --------------------------------------------------------------------------------------------------------------- **/
/** Modifiers                                                                                                       **/
/** --------------------------------------------------------------------------------------------------------------- **/

terminal Token MOBILE       ; // "mobile"
terminal Token NATIVE       ; // "native"
terminal Token PUBLIC       ; // "public"
terminal Token PRIVATE      ; // "private"
terminal Token PROTECTED    ; // "protected"
terminal Token CONST        ; // "const"
terminal Token EXTERN       ; // "extern"

/** --------------------------------------------------------------------------------------------------------------- **/
/** Keywords                                                                                                        **/
/** --------------------------------------------------------------------------------------------------------------- **/

terminal Token BREAK        ; // "break"
terminal Token CASE         ; // "case"
terminal Token CONTINUE     ; // "continue"
terminal Token DO           ; // "do"
terminal Token DEFAULT      ; // "default"
terminal Token ELSE         ; // "else"
terminal Token EXTENDS      ; // "extends"
terminal Token FOR          ; // "for"
terminal Token IF           ; // "if"
terminal Token IMPLEMENTS   ; // "implements"
terminal Token IMPORT       ; // "import"
terminal Token IS           ; // "instanceof"
terminal Token NEW          ; // "new"
terminal Token PACKAGE      ; // "package"
terminal Token RETURN       ; // "return"
terminal Token SWITCH       ; // "switch"
terminal Token WHILE        ; // "while"
terminal Token PRAGMA       ; // "pragma"

/** --------------------------------------------------------------------------------------------------------------- **/
/** Process Keywords                                                                                                **/
/** --------------------------------------------------------------------------------------------------------------- **/

terminal Token ALT          ; // "alt"
terminal Token CHAN         ; // "chan"
terminal Token CLAIM        ; // "claim"
terminal Token ENROLL       ; // "enroll"
terminal Token FORK         ; // "fork"
terminal Token PAR          ; // "par"
terminal Token PRI          ; // "pri"
terminal Token PROC         ; // "proc"
terminal Token PROTOCOL     ; // "protocol"
terminal Token READ         ; // "read"
terminal Token RECORD       ; // "record"
terminal Token RESUME       ; // "resume"
terminal Token SEQ          ; // "seq"
terminal Token SHARED       ; // "shared"
terminal Token SKIP         ; // "skip"
terminal Token STOP         ; // "stop"
terminal Token SYNC         ; // "sync"
terminal Token SUSPEND      ; // "suspend"
terminal Token TIMEOUT      ; // "timeout"
terminal Token WITH         ; // "with"
terminal Token WRITE        ; // "write"

/** --------------------------------------------------------------------------------------------------------------- **/
/** Separators                                                                                                      **/
/** --------------------------------------------------------------------------------------------------------------- **/

terminal Token LPAREN       ; // "("
terminal Token RPAREN       ; // ")"
terminal Token LBRACK       ; // "["
terminal Token RBRACK       ; // "]"
terminal Token LBRACE       ; // "{"
terminal Token RBRACE       ; // "}"
terminal Token SEMICOLON    ; // ";"
terminal Token COMMA        ; // ","
terminal Token DOT          ; // "."
terminal Token QUEST        ; // "?"
terminal Token COLON        ; // ":"
terminal Token COLONCOLON   ; // "::"

/** --------------------------------------------------------------------------------------------------------------- **/
/** Unary Operators                                                                                                 **/
/** --------------------------------------------------------------------------------------------------------------- **/

terminal Token NOT          ; // "!"
terminal Token COMP         ; // "~"
terminal Token PLUSPLUS     ; // "++"
terminal Token MINUSMINUS   ; // "--"

/** --------------------------------------------------------------------------------------------------------------- **/
/** Bitwise Operators                                                                                               **/
/** --------------------------------------------------------------------------------------------------------------- **/

terminal Token AND          ; // "&"
terminal Token XOR          ; // "^"
terminal Token OR           ; // "|"
terminal Token LSHIFT       ; // "<<"
terminal Token RSHIFT       ; // ">>"
terminal Token RRSHIFT      ; // ">>>"

/** --------------------------------------------------------------------------------------------------------------- **/
/** Logical Operators                                                                                               **/
/** --------------------------------------------------------------------------------------------------------------- **/

terminal Token ANDAND       ; // "&&"
terminal Token OROR         ; // "||"
terminal Token EQEQ         ; // "=="
terminal Token NOTEQ        ; // "!="

/** --------------------------------------------------------------------------------------------------------------- **/
/** Relational Operators                                                                                            **/
/** --------------------------------------------------------------------------------------------------------------- **/

terminal Token GT           ; // ">"
terminal Token LT           ; // "<"
terminal Token LTEQ         ; // "<="
terminal Token GTEQ         ; // ">="

/** --------------------------------------------------------------------------------------------------------------- **/
/** Arithmetic Operators                                                                                            **/
/** --------------------------------------------------------------------------------------------------------------- **/

terminal Token PLUS         ; // "+"
terminal Token MINUS        ; // "-"
terminal Token MULT         ; // "*"
terminal Token DIV          ; // "/"
terminal Token MOD          ; // "%"
terminal Token EQ           ; // "="

/** --------------------------------------------------------------------------------------------------------------- **/
/** Compound Assignment Operators                                                                                   **/
/** --------------------------------------------------------------------------------------------------------------- **/

terminal Token ANDEQ        ; // "&="
terminal Token XOREQ        ; // "^="
terminal Token OREQ         ; // "|="
terminal Token LSHIFTEQ     ; // "<<="
terminal Token RSHIFTEQ     ; // ">>="
terminal Token RRSHIFTEQ    ; // ">>>="
terminal Token PLUSEQ       ; // "+="
terminal Token MINUSEQ      ; // "-="
terminal Token MULTEQ       ; // "*="
terminal Token DIVEQ        ; // "/="
terminal Token MODEQ        ; // "%="

/** --------------------------------------------------------------------------------------------------------------- **/
/** Atomic Types                                                                                                    **/
/** --------------------------------------------------------------------------------------------------------------- **/

terminal Token BOOLEAN      ; // "boolean"
terminal Token BYTE         ; // "byte"
terminal Token CHAR         ; // "char"
terminal Token DOUBLE       ; // "double"
terminal Token FLOAT        ; // "float"
terminal Token INT          ; // "int"
terminal Token LONG         ; // "long"
terminal Token SHORT        ; // "short"
terminal Token STRING       ; // "string"
terminal Token VOID         ; // "void"
terminal Token BARRIER      ; // "barrier"
terminal Token TIMER        ; // "timer"

/** --------------------------------------------------------------------------------------------------------------- **/
/** Boolean Literals                                                                                                **/
/** --------------------------------------------------------------------------------------------------------------- **/

terminal Token BOOLEAN_LITERAL      ; // "true" or "false"

/** --------------------------------------------------------------------------------------------------------------- **/
/** Boolean Literals                                                                                                **/
/** --------------------------------------------------------------------------------------------------------------- **/

terminal Token NULL_LITERAL         ; // "null"

/** --------------------------------------------------------------------------------------------------------------- **/
/** Numeric Literals                                                                                                **/
/** --------------------------------------------------------------------------------------------------------------- **/

terminal Token INTEGER_LITERAL      ;
terminal Token LONG_LITERAL         ;
terminal Token FLOAT_LITERAL        ;
terminal Token DOUBLE_LITERAL       ;
terminal Token CHARACTER_LITERAL    ;
terminal Token STRING_LITERAL       ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** Identifier                                                                                                      **/
/** --------------------------------------------------------------------------------------------------------------- **/

terminal Token IDENTIFIER           ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** Non-Terminals                                                                                                   **/
/** --------------------------------------------------------------------------------------------------------------- **/

/** --------------------------------------------------------------------------------------------------------------- **/
/** 1.0 Source                                                                                                      **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal Compilation                source                                  ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 2.0 Type Declarations                                                                                           **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal Sequence                   type_declarations_opt                   ;
non terminal Sequence                   type_declarations                       ;
non terminal Sequence                   type_declaration                        ;
non terminal Name                       extern_type                             ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 2.1 Procedure Type Declarations                                                                                 **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal ProcedureTypeDeclaration   procedure_type_declaration              ;
non terminal BlockStatement             body_opt                                ;
non terminal Sequence                   implements_opt                          ;
non terminal Sequence                   type_list                               ;
non terminal Sequence                   formal_parameter_list_opt               ;
non terminal Sequence                   formal_parameter_list                   ;
non terminal ParameterDeclaration       formal_parameter                        ;
non terminal Sequence                   package_access                          ;
non terminal Name                       type_name                               ;
non terminal Annotations                annotations_opt                         ;
non terminal Sequence                   annotations                             ;
non terminal Annotation                 range                                   ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 2.2 Protocol Type Declarations                                                                                  **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal ProtocolTypeDeclaration    protocol_type_declaration               ;
non terminal Sequence                   extends_opt                             ;
non terminal Sequence                   protocol_body                           ;
non terminal Sequence                   protocol_cases                          ;
non terminal ProtocolCase               protocol_case                           ;
non terminal Sequence                   record_body_opt                         ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 2.3 Record Type Declarations                                                                                    **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal RecordTypeDeclaration      record_type_declaration                 ;
non terminal Sequence                   record_body                             ;
non terminal Sequence                   record_member_declarations              ;
non terminal Sequence                   record_member_declaration               ;
non terminal Sequence                   record_member_declarators               ;
non terminal Name                       record_member_declarator                ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 3.0 Types                                                                                                       **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal Type                       type                                    ;
non terminal PrimitiveType              primitive_type                          ;
non terminal NamedType                  named_type                              ; // TODO: I don't think we ever need this one in the parse tree to be honest.
non terminal ArrayType                  array_type                              ;
non terminal Type                       channel_type                            ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 5.0 Packages                                                                                                    **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal Compilation                compilation_unit                        ;
non terminal Sequence                   package_declaration_opt                 ;
non terminal Sequence                   package_declaration                     ;
non terminal Sequence                   pragmas_opt                             ;
non terminal Sequence                   pragmas                                 ;
non terminal Pragma                     pragma                                  ;
non terminal Sequence                   import_declarations_opt                 ;
non terminal Sequence                   import_declarations                     ;
non terminal Import                     import_declaration                      ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 6.0 Modifiers                                                                                                   **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal Modifiers                  modifiers_opt                           ;
non terminal Modifiers                  modifiers                               ;
non terminal Modifier                   modifier                                ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 7.0 Constants & Variable Declarations                                                                           **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal Sequence                   constant_declaration                    ;
non terminal Sequence                   constant_declarators                    ;
non terminal Var                        constant_declarator                     ;
non terminal Sequence                   variable_declarators                    ;
non terminal Var                        variable_declarator                     ;
non terminal Name                       variable_declarator_identifier          ;
non terminal Expression                 variable_initializer                    ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 8.0 Arrays                                                                                                      **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal ArrayLiteralExpression     array_initializer                       ;
non terminal Sequence                   variable_initializers_opt               ;
non terminal Sequence                   variable_initializers                   ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 9.0 Blocks & Statements                                                                                         **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal BlockStatement             block_opt                               ;
non terminal BlockStatement             block                                   ;
non terminal Sequence                   block_statements_opt                    ;
non terminal Sequence                   block_statements                        ;
non terminal ParBlock                   par_block                               ;
non terminal Sequence                   barriers                                ;
non terminal Sequence                   block_statement                         ;
non terminal Sequence                   local_variable_declaration              ;
non terminal Statement                  statement                               ;
non terminal Statement                  statement_no_short_if                   ;
non terminal Statement                  statement_without_trailing_substatement ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 9.1 If Statements                                                                                               **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal IfStatement                if_then_statement                       ;
non terminal IfStatement                if_then_else_statement                  ;
non terminal IfStatement                if_then_else_statement_no_short_if      ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 9.2 While/For/Do Statements                                                                                     **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal WhileStatement             while_statement                         ;
non terminal WhileStatement             while_statement_no_short_if             ;
non terminal ForStatement               for_statement                           ;
non terminal ForStatement               for_statement_no_short_if               ;
non terminal Sequence                   for_init_opt                            ;
non terminal Sequence                   for_init                                ;
non terminal Sequence                   for_update_opt                          ;
non terminal Sequence                   for_update                              ;
non terminal Sequence                   statement_expressions                   ;
non terminal Sequence                   enroll_opt                              ;
non terminal DoStatement                do_statement                            ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 9.3 Claim Statement                                                                                             **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal ClaimStatement             claim_statement                         ;
non terminal ClaimStatement             claim_statement_no_short_if             ;
non terminal Sequence                   channels                                ;
non terminal AST                        channel                                 ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 9.4 Empty Statement                                                                                             **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal Statement                  empty_statement                         ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 9.5 Barrier Sync & Timeout Statements                                                                           **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal SyncStatement              barrier_sync_statement                  ;
non terminal TimeoutStatement           timeout_statement                       ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 9.6 Suspend Statement                                                                                           **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal SuspendStatement           suspend_statement                       ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 9.7 Expression Statement & Labelled Statements                                                                  **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal ExpressionStatement        expression_statement                    ;
non terminal Expression                 statement_expression                    ;
non terminal Statement                  labeled_statement                       ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 9.8 Break/Continue/Return Statements                                                                            **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal BreakStatement             break_statement                         ;
non terminal ContinueStatement          continue_statement                      ;
non terminal Name                       identifier_opt                          ;
non terminal ReturnStatement            return_statement                        ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 9.9 Switch Statement                                                                                            **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal SwitchStatement            switch_statement                        ;
non terminal Sequence                   switch_block                            ;
non terminal Sequence                   switch_block_statement_groups_opt       ;
non terminal Sequence                   switch_block_statement_groups           ;
non terminal SwitchGroupStatement       switch_block_statement_group            ;
non terminal Sequence                   switch_labels                           ;
non terminal SwitchLabel                switch_label                            ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 9.10 Skip/Stop Statements                                                                                       **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal StopStatement              stop_statement                          ;
non terminal SkipStatement              skip_statement                          ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 9.11 Alt Statement                                                                                              **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal AltStatement               alt_statement                           ;
non terminal Sequence                   alt_body                                ;
non terminal AltCase                    alt_case                                ;
non terminal GuardStatement             guardStatement                          ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 10.0 Expressions                                                                                                **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal Expression                 primary                                 ;
non terminal Expression                 primary_no_new_array_or_mobile          ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 10.1 Array Creation Expressions                                                                                 **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal NewArrayExpression         array_creation_expression               ;
non terminal Sequence                   dim_exprs                               ;
non terminal Expression                 dim_expr                                ;
non terminal Sequence                   dims_opt                                ;
non terminal Sequence                   dims                                    ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 10.2 Mobile Creation Expression                                                                                 **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal NewMobileExpression        mobile_creation                         ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 10.3 Channel Expression/Channel Read Expression                                                                 **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal ChannelEndExpression       chan_expression                         ;
non terminal ChannelReadExpression      chan_read_expression                    ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 10.4 Structured Access                                                                                          **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal Expression                 record_access                           ;
non terminal ArrayAccessExpression      array_access                            ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 10.5 Invocation Expression                                                                                      **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal InvocationExpression       invocation_expression                   ;
non terminal Sequence                   argument_list_opt                       ;
non terminal Sequence                   argument_list                           ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 10.6 Expressions                                                                                                **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal Expression                 postfix_expression                      ;
non terminal UnaryPostExpression        post_increment_expression               ;
non terminal UnaryPostExpression        post_decrement_expression               ;
non terminal Expression                 unary_expression                        ;
non terminal UnaryPreExpression         pre_increment_expression                ;
non terminal UnaryPreExpression         pre_decrement_expression                ;
non terminal Expression                 unary_expression_not_plus_minus         ;
non terminal CastExpression             cast_expression                         ;
non terminal Expression                 multiplicative_expression               ;
non terminal Expression                 additive_expression                     ;
non terminal Expression                 shift_expression                        ;
non terminal Expression                 relational_expression                   ;
non terminal Expression                 equality_expression                     ;
non terminal Expression                 and_expression                          ;
non terminal Expression                 exclusive_or_expression                 ;
non terminal Expression                 inclusive_or_expression                 ;
non terminal Expression                 conditional_and_expression              ;
non terminal Expression                 conditional_or_expression               ;
non terminal Expression                 conditional_expression                  ;
non terminal Expression                 assignment_expression                   ;
non terminal AssignmentExpression       assignment                              ;
non terminal Integer                    assignment_operator                     ;
non terminal Expression                 left_hand_side                          ;
non terminal Expression                 expression_opt                          ;
non terminal Expression                 expression                              ;
non terminal Expression                 constant_expression                     ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 11.0 Literal Expressions (See 8.0 for Array Literals)                                                           **/
/** --------------------------------------------------------------------------------------------------------------- **/

non terminal LiteralExpression          literal                                 ;
non terminal RecordLiteralExpression    record_literal                          ;
non terminal Sequence                   record_literal_argument_list_opt        ;
non terminal Sequence                   record_literal_argument_list            ;
non terminal ProtocolLiteralExpression  protocol_literal                        ;

/** --------------------------------------------------------------------------------------------------------------- **/
/** Productions                                                                                                     **/
/** --------------------------------------------------------------------------------------------------------------- **/

start with source;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 1.0 Source                                                                                                      **/
/** --------------------------------------------------------------------------------------------------------------- **/

// Compilation <: AST
source
::=
    compilation_unit:c                  {: RESULT = c                                               ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 2.0 Type Declarations                                                                                           **/
/** --------------------------------------------------------------------------------------------------------------- **/

// TODO: should user-defined types have a super class "TypeDecl"?

// Sequence[Type <: AST] <: AST
type_declarations_opt
::=
    type_declarations:ts                {: RESULT = ts                                              ;:}
|   /* epsilon */                       {: RESULT = new Sequence<Type>()                            ;:}
;

// Sequence[Type <: AST] <: AST
type_declarations
::=
    type_declarations:ts
    type_declaration:td                 {: RESULT = ts.merge(td)                                    ;:}
|   type_declaration:td                 {: RESULT = td                                              ;:}
;

// Sequence[Type <: AST] <: AST
type_declaration
::= // TODO: We might be able to assign the package elsewhere
    procedure_type_declaration:p        {:  RESULT = new Sequence<Type>(p)                          ;:}
|   record_type_declaration:r           {:  RESULT = new Sequence<Type>(r)                          ;:}
|   protocol_type_declaration:p         {:  RESULT = new Sequence<Type>(p)                          ;:}
|   constant_declaration:c              {:  RESULT = c                                              ;:}
|   EXTERN extern_type:e IDENTIFIER:n   {:  RESULT = new Sequence<Type>(new NamedType(new Name(n), new ExternType(e)));:}
;

// Name <: AST
extern_type
::=
    IDENTIFIER:i                        {: RESULT = new Name(i)                                     ;:}
|   extern_type:e
    DOT
    IDENTIFIER:i                        {: e.setName(e.getName() + "." + i.lexeme); RESULT = e      ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 2.1 Procedure Types                                                                                             **/
/** --------------------------------------------------------------------------------------------------------------- **/

// ProcTypeDecl <: Type <: AST
procedure_type_declaration
::=
    modifiers_opt:m
    // PROC
    type:t
    IDENTIFIER:id
    LPAREN
    formal_parameter_list_opt:f
    RPAREN
    annotations_opt:a
    implements_opt:i
    body_opt:b                          {: RESULT = new ProcedureTypeDeclaration(a, m, t, new Name(id), f, i, b)    ;:}
|   modifiers_opt:m
    // PROC
    VOID:t
    IDENTIFIER:id
    LPAREN
    formal_parameter_list_opt:f
    RPAREN
    annotations_opt:a
    implements_opt:i
    body_opt:b                          {: RESULT = new ProcedureTypeDeclaration(a, m, new PrimitiveType(t, PrimitiveType.VoidKind),
                                                        new Name(id), f, i, b)                       ;:}
;

// Annotations <: AST
annotations_opt
::=
    LBRACK
    annotations:a
    RBRACK                              {: RESULT = new Annotations(a)                                  ;:}
|   /* empty */                         {: RESULT = new Annotations()                                   ;:}
;

// Sequence<Annotations> <: AST
annotations
::=
    range:a                             {: RESULT = new Sequence(a)                                     ;:}
|   annotations:as
    COMMA
    range:a                             {: RESULT = as.append(a)                                        ;:}
;

// Annotation <: AST
range
::=
    IDENTIFIER:i EQ IDENTIFIER:v        {: RESULT = new Annotation(i.lexeme, v.lexeme)                  ;:}
|   IDENTIFIER:i EQ BOOLEAN_LITERAL:v   {: RESULT = new Annotation(i.lexeme, v.lexeme)                  ;:}
|   IDENTIFIER:i EQ INTEGER_LITERAL:v   {: RESULT = new Annotation(i.lexeme, v.lexeme)                  ;:}
|   IDENTIFIER:i EQ LONG_LITERAL:v      {: RESULT = new Annotation(i.lexeme, v.lexeme)                  ;:}
|   IDENTIFIER:i EQ FLOAT_LITERAL:v     {: RESULT = new Annotation(i.lexeme, v.lexeme)                  ;:}
|   IDENTIFIER:i EQ DOUBLE_LITERAL:v    {: RESULT = new Annotation(i.lexeme, v.lexeme)                  ;:}
;

// Block <: Statement <: AST
body_opt
::=
    block:b                             {: RESULT = b                                                   ;:}
|   SEMICOLON                           {: RESULT = null                                                ;:}
;

// Sequence[Name <: AST] <: AST
implements_opt
::=
    IMPLEMENTS
    type_list:t                         {: RESULT = t                                                   ;:}
|   /* Epsilon */                       {: RESULT = new Sequence<Name>()                                ;:}
;

// Sequence[Name <: AST] <: AST
type_list
::=
    type_list:tl
    COMMA
    type_name:tn                        {: RESULT = tl.append(tn)                                       ;:}
|   type_name:tn                        {: RESULT = new Sequence<Name>(tn)                              ;:}
;

// Name
type_name
::=
    IDENTIFIER:id                       {: RESULT = new Name(id)                                        ;:}
|   package_access:pa
    COLONCOLON
    IDENTIFIER:id                       {: RESULT = new Name(id, pa)                                    ;:}
;

// Sequence[Name <: AST] <: AST
package_access
::=
    IDENTIFIER:id                       {: RESULT = new Sequence<Name>(new Name(id))                    ;:}
|   package_access:pa
    DOT
    IDENTIFIER:id                       {: RESULT = pa.append(new Name(id))                             ;:}
;

// Sequence[ParameterDeclaration <: AST] <: AST
formal_parameter_list_opt
::=
    formal_parameter_list:f             {: RESULT = f                                                   ;:}
|   /* Epsilon */                       {: RESULT = new Sequence<ParameterDeclaration>()                ;:}
;

// Sequence[ParameterDeclaration <: AST] <: AST
formal_parameter_list
::=
    formal_parameter_list:lst
    COMMA
    formal_parameter:e                  {: RESULT = lst.append(e)                                       ;:}
|   formal_parameter:e                  {: RESULT = new Sequence<ParameterDeclaration>(e)               ;:}
;

// ParameterDeclaration <: AST
formal_parameter
::=
    type:t
    variable_declarator_identifier:v   {: RESULT = new ParameterDeclaration(t, v, false)                ;:}
|   CONST
    type:t
    variable_declarator_identifier:v   {: RESULT = new ParameterDeclaration(t, v, true)                 ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 2.2 Protocol Types                                                                                              **/
/** --------------------------------------------------------------------------------------------------------------- **/

// ProtocolTypeDecl <: Type <: AST
protocol_type_declaration
::=
    modifiers_opt:m
    PROTOCOL
    IDENTIFIER:id
    extends_opt:e
    annotations_opt:a
    protocol_body:b                     {: RESULT = new ProtocolTypeDeclaration(m, new Name(id), e, a, b)      ;:}
|   modifiers_opt:m
    PROTOCOL
    IDENTIFIER:id
    extends_opt:e
    annotations_opt:a
    SEMICOLON                           {: RESULT = new ProtocolTypeDeclaration(m, new Name(id), e, a, null)   ;:}
;

// Sequence[Name <: AST] <: AST
extends_opt
::=
    EXTENDS type_list:t                 {: RESULT = t                                                   ;:}
|   /* Epsilon */                       {: RESULT = new Sequence<Name>()                                ;:}
;

// Sequence[ProtocolCase <: AST] <: AST
protocol_body
::=
    LBRACE protocol_cases:p RBRACE      {: RESULT = p                                                   ;:}
;

// Sequence[ProtocolCase <: AST] <: AST
protocol_cases
::=
    protocol_cases:lst
    protocol_case:e                     {: RESULT = lst.append(e)                                       ;:}
|   protocol_case:e                     {: RESULT = new Sequence<ProtocolCase>(e)                       ;:}
;

// ProtocolCase <: AST
protocol_case
::=
    IDENTIFIER:id
    COLON
    record_body_opt:r                   {: RESULT = new ProtocolCase(new Name(id), r)                   ;:}
;

// Sequence[RecordMember <: AST] <: AST
record_body_opt
::=
    record_body:r                           {: RESULT = r                                                   ;:}
//|   LBRACE /* empty */ RBRACE             {: RESULT = new Sequence<RecordMemberDeclaration>()             ;:}
;

// Sequence[ProtocolCaseDecl <: AST] <: AST
// ProtocolCaseDecl is a Type and a Name
//protocol_case_declarations
//::=
//  protocol_case_declarations:lst
//  SEMICOLON type:t
//  variable_declarator_identifier:v {: RESULT = lst.append(new ProtocolM) ;:}
//|   type variable_declarator_identifier {: RESULT = new Sequence<RecordMemberDeclaration>(new ProtocolCaseDecl($1, $2)) ;:}
//;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 2.3 Record Types                                                                                                **/
/** --------------------------------------------------------------------------------------------------------------- **/

// RecordTypeDecl <: Type <: AST
record_type_declaration
::=
    modifiers_opt:m
    RECORD
    IDENTIFIER:id
    extends_opt:e
    annotations_opt:a
    record_body:r                       {: RESULT = new RecordTypeDeclaration(m, new Name(id), e, a, r)        ;:}
;

// Sequence[RecordMember <: AST] <: AST
record_body
::=
    LBRACE
    record_member_declarations:r
    RBRACE                              {: RESULT = r                                                   ;:}
|   LBRACE /* empty */ RBRACE           {: RESULT = new Sequence<RecordMemberDeclaration>()             ;:}
;

// Sequence[RecordMember <: AST] <: AST
record_member_declarations
::=
    record_member_declarations:lst
    record_member_declaration:e         {: RESULT = lst.merge(e)                                        ;:}
|   record_member_declaration:e         {: RESULT = e                                                   ;:}
;

// RecordMember <: AST
record_member_declaration
::=
    type:t
    record_member_declarators:r
    SEMICOLON                           {: final Sequence sequence = new Sequence<RecordMemberDeclaration>();
                                           for(final Name name: (Sequence<Name>) r)
                                               sequence.append(new RecordMemberDeclaration(t, name));
                                           RESULT = sequence                                            ;:}
;

// Sequence[Name <: AST] <: AST
record_member_declarators
::=
    record_member_declarators:lst
    COMMA
    record_member_declarator:e          {: RESULT = lst.append(e)                                       ;:}
|   record_member_declarator:e          {: RESULT = new Sequence<Name>(e)                               ;:}
;

// Name <: AST
record_member_declarator
::=
    variable_declarator_identifier:v    {: RESULT = v                                                   ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 3.0 Types                                                                                                       **/
/** --------------------------------------------------------------------------------------------------------------- **/

// Type <: AST
type
::=
    primitive_type:t                    {: RESULT = t                                                       ;:}
|   array_type:t                        {: RESULT = t                                                       ;:}
|   channel_type:t                      {: RESULT = t                                                       ;:}
|   named_type:t                        {: RESULT = t                                                       ;:}
;

// PrimitiveType <: Type <: AST
primitive_type
::=
    BOOLEAN:t                           {: RESULT = new PrimitiveType(t, PrimitiveType.BooleanKind)         ;:}
|   CHAR:t                              {: RESULT = new PrimitiveType(t, PrimitiveType.CharKind)            ;:}
|   BYTE:t                              {: RESULT = new PrimitiveType(t, PrimitiveType.ByteKind)            ;:}
|   SHORT:t                             {: RESULT = new PrimitiveType(t, PrimitiveType.ShortKind)           ;:}
|   INT:t                               {: RESULT = new PrimitiveType(t, PrimitiveType.IntKind)             ;:}
|   LONG:t                              {: RESULT = new PrimitiveType(t, PrimitiveType.LongKind)            ;:}
|   FLOAT:t                             {: RESULT = new PrimitiveType(t, PrimitiveType.FloatKind)           ;:}
|   DOUBLE:t                            {: RESULT = new PrimitiveType(t, PrimitiveType.DoubleKind)          ;:}
|   STRING:t                            {: RESULT = new PrimitiveType(t, PrimitiveType.StringKind)          ;:}
|   BARRIER:t                           {: RESULT = new PrimitiveType(t, PrimitiveType.BarrierKind)         ;:}
|   TIMER:t                             {: RESULT = new PrimitiveType(t, PrimitiveType.TimerKind)           ;:}
;

// NamedType <: Type <: AST
named_type
::=
    IDENTIFIER:id                       {: RESULT = new NamedType(new Name(id))                             ;:}
;

// ArrayType <: Type <: AST
array_type
::=
    primitive_type:t
    dims:d                              {: RESULT = new ArrayType(t, d.size())                              ;:}
|   channel_type:t
    dims:d                              {: RESULT = new ArrayType(t, d.size())                              ;:}
|   IDENTIFIER:id
    dims:d                              {: RESULT = new ArrayType(new NamedType(new Name(id)), d.size())    ;:}
|   primary:p
    COLONCOLON
    IDENTIFIER:id
    dims:d                              {: RESULT = new ArrayType(new NamedType(new Name(id,
                                                        primary2PackageAccess(p))), d.size())               ;:}
;
    
// Type <: AST
// (which is a super class of ChannelEndType)
channel_type
::=
    SHARED
    READ
    CHAN
    LT
    type:t
    GT                                  {: RESULT = new ChannelType(t, ChannelType.SHARED_READ)         ;:}
|   SHARED
    WRITE
    CHAN
    LT
    type:t
    GT                                  {: RESULT = new ChannelType(t, ChannelType.SHARED_WRITE)        ;:}
|   SHARED
    CHAN
    LT
    type:t
    GT                                  {: RESULT = new ChannelType(t, ChannelType.SHARED_READ_WRITE)   ;:}
|   CHAN
    LT
    type:t
    GT                                  {: RESULT = new ChannelType(t, ChannelType.NOT_SHARED)          ;:}
|   CHAN
    LT
    type:t
    GT
    DOT
    READ                                {: RESULT = new ChannelEndType(ChannelEndType.NOT_SHARED, t, ChannelEndType.READ_END)   ;:}
|   CHAN
    LT
    type:t
    GT
    DOT
    WRITE                               {: RESULT = new ChannelEndType(ChannelEndType.NOT_SHARED, t, ChannelEndType.WRITE_END)  ;:}
|   SHARED
    CHAN
    LT
    type:t
    GT
    DOT
    READ                                {: RESULT = new ChannelEndType(ChannelEndType.SHARED, t, ChannelEndType.READ_END)       ;:}
|   SHARED
    CHAN
    LT
    type:t
    GT
    DOT
    WRITE                               {: RESULT = new ChannelEndType(ChannelEndType.SHARED, t, ChannelEndType.WRITE_END)      ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 5.0 Packages                                                                                                    **/
/** --------------------------------------------------------------------------------------------------------------- **/

// Compilation <: AST
compilation_unit
::=
    pragmas_opt:pr
    package_declaration_opt:p
    import_declarations_opt:i
    type_declarations_opt:t             {: RESULT = new Compilation(pr, p, i, t)                            ;:}
;

// Sequence(Pragma <: AST) <: AST
pragmas_opt
::=
    pragmas:ps                          {: RESULT = ps                                                      ;:}
|   /* Epsilon */                       {: RESULT = new Sequence<Pragma>()                                  ;:}
;

// Sequence(Pragma <: AST) <: AST
pragmas
::=
    pragma:p                            {: RESULT = new Sequence<Pragma>(p)                                 ;:}
|   pragmas:ps
    pragma:p                            {: RESULT = ps.append(p)                                            ;:}
;

// Pragma <: AST
pragma
::=
    PRAGMA
    IDENTIFIER:pn
    STRING_LITERAL:s
    SEMICOLON                           {: RESULT = new Pragma(new Name(pn), s.lexeme)                      ;:}
|   PRAGMA
    IDENTIFIER:pn
    SEMICOLON                           {: RESULT = new Pragma(new Name(pn), null)                          ;:}
;

// Name <: AST
package_declaration_opt
::=
    package_declaration:p               {: RESULT = p                                                       ;:}
|   /* Epsilon */                       {: RESULT = null                                                    ;:}
;

// Sequence<Name> <: AST
package_declaration
::=
    PACKAGE
    //IDENTIFIER:id
    package_access:p
    SEMICOLON                           {: RESULT = p                                                       ;:}
;

// Sequence[Import <: AST] <: AST
import_declarations_opt
::=
    import_declarations:i               {: RESULT = i                                                       ;:}
|   /* Epsilon */                       {: RESULT = new Sequence<Import>()                                  ;:}
;

// Sequence[Import <: AST] <: AST
import_declarations
::=
    import_declarations:lst
    import_declaration:e                {: RESULT = lst.append(e)                                           ;:}
|   import_declaration:e                {: RESULT = new Sequence<Import>(e)                                 ;:}
;

// Import <: AST
import_declaration
::=
    IMPORT
    package_access:p
    SEMICOLON                           {: RESULT = new Import(p)                                           ;:}
|   IMPORT
    package_access:p
    DOT
    MULT:m
    SEMICOLON                           {: RESULT = new Import(p.append(new Name(m)))                       ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 6.0 Modifiers                                                                                                   **/
/** --------------------------------------------------------------------------------------------------------------- **/

// Sequence[Modifier <: AST] <: AST
modifiers_opt
::=
    modifiers:m                         {: RESULT = m                                                       ;:}
|   /* Epsilon */                       {: RESULT = new Modifiers()                                         ;:}
;

// Sequence[Modifier <: AST] <: AST
modifiers
::=
    modifiers:lst
    modifier:e                          {: RESULT = lst.add(e)                                              ;:}
|   modifier:e                          {: RESULT = new Modifiers(e)                                        ;:}
;

// Modifier <: AST
modifier
::=
    MOBILE:m                            {: RESULT = new Mobile(m)                                           ;:}
|   CONST:m                             {: RESULT = new Constant(m)                                         ;:}
|   NATIVE:m                            {: RESULT = new Native(m)                                           ;:}
|   PUBLIC:m                            {: RESULT = new Public(m)                                           ;:}
|   PRIVATE:m                           {: RESULT = new Private(m)                                          ;:}
|   PROTECTED:m                         {: RESULT = new Protected(m)                                        ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 7.0 Constants and Variable Declarations                                                                         **/
/** --------------------------------------------------------------------------------------------------------------- **/

// Sequence[ConstantDecl <: AST] <: AST
constant_declaration
::=
    modifiers_opt:m
    type:t
    constant_declarators:c
    SEMICOLON                           {: final Sequence sequence = new Sequence<ConstantDeclaration>();
                                           for(final Var variable: (Sequence<Var>) c)
                                               sequence.append(new ConstantDeclaration(m, t, variable));
                                           RESULT = sequence                                                ;:}
;

// Sequence[Var <: AST] <: AST
constant_declarators
::=
    constant_declarators:lst
    COMMA
    constant_declarator:e               {: RESULT = lst.append(e)                                           ;:}
|   constant_declarator:e               {: RESULT = new Sequence<Var>(e)                                    ;:}
;

// Var <: AST
constant_declarator
::=
    variable_declarator_identifier:v
    EQ
    variable_initializer:i              {: RESULT = new Var(v, i)                                           ;:}
|   variable_declarator_identifier:v    {: RESULT = new Var(v, null)                                        ;:}
;

// Sequence[Var <: AST] <: AST
variable_declarators
::=
    variable_declarators:lst
    COMMA
    variable_declarator:e               {: RESULT = lst.append(e)                                           ;:}
|   variable_declarator:e               {: RESULT = new Sequence<Var>(e)                                    ;:}
;

// Var <: AST
variable_declarator
::=
    variable_declarator_identifier:v    {: RESULT = new Var(v, null)                                        ;:}
|   variable_declarator_identifier:v
    EQ
    variable_initializer:i              {: RESULT = new Var(v, i)                                           ;:}
;

// Name <: AST
variable_declarator_identifier
::=
    IDENTIFIER:id                       {: RESULT = new Name(id)                                            ;:}
|   variable_declarator_identifier:v
    LBRACK
    RBRACK                              {: v.setDepth(v.getDepth() + 1); RESULT = v               ;:}
;

// Expression <: AST
variable_initializer
::=
    array_initializer:a                 {: RESULT = a                                                       ;:}
|   expression:e                        {: RESULT = e                                                       ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 8.0 Arrays                                                                                                      **/
/** --------------------------------------------------------------------------------------------------------------- **/

// ArrayLiteral <: Expression <: AST
array_initializer
::=
    LBRACE
    variable_initializers_opt:v
    RBRACE                              {: RESULT = new ArrayLiteralExpression(v)                                   ;:}
;

// Sequence[Expression <: AST] <: AST
variable_initializers_opt
::=
    variable_initializers:v             {: RESULT = v                                                       ;:}
|   /* Epsilon */                       {: RESULT = new Sequence<Expression>()                              ;:}
;

// Sequence[Expression <: AST] <: AST
variable_initializers
::=
    variable_initializers:lst
    COMMA
    variable_initializer:e              {: RESULT = lst.append(e)                                           ;:}
|   variable_initializer:e              {: RESULT = new Sequence<Expression>(e)                             ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 9.0 Blocks and statements                                                                                       **/
/** --------------------------------------------------------------------------------------------------------------- **/

// Block <: Statment <: AST
block_opt
::=
    block:b                             {: RESULT = b                                                       ;:}
|   /* Epsilon */                       {: RESULT = new BlockStatement()                                             ;:}
;

// Block <: Statement <: AST
block
::=
    LBRACE
    block_statements_opt:b
    RBRACE                              {: RESULT = new BlockStatement(b)                                          ;:}
;

// Sequence[Statement <: AST] <: AST
block_statements_opt
::=
    block_statements:b                  {: RESULT = b                                                       ;:}
|   /* Epsilon */                       {: RESULT = new Sequence<Statement>()                               ;:}
;

// Sequence[Statement <: AST] <: AST
block_statements
::=
    block_statements:lst
    block_statement:e                   {: RESULT = lst.merge(e)                                            ;:}
|   block_statement:e                   {: RESULT = e                                                       ;:}
;

// ParBlock  <: Statement <: AST
par_block
::=
    PAR
    block:bl                                    {: RESULT = new ParBlock(bl.getStatements(), new Sequence<Expression>())    ;:}
|   PAR
    ENROLL
    barriers:b
    block:bl                                    {: RESULT = new ParBlock(bl.getStatements(), b)                             ;:}
//| PAR
//  ENROLL
//  LPAREN
//  barriers:b
//  RPAREN block:bl                         {: RESULT = new ParBlock(bl.getStatements(), b)                             ;:}
;

// Sequence[Expression <: AST] <: AST
// might have to allow abbreviations like in claims
barriers
::=
    barriers:lst
    COMMA
    expression:e                        {: RESULT = lst.append(e)                                           ;:}
|   expression:e                        {: RESULT = new Sequence<Expression>(e)                             ;:}
;

// Sequence[Statement <: AST] <: AST
block_statement
::=
    local_variable_declaration:l
    SEMICOLON                           {: RESULT = l                                                       ;:}
|   statement:s                         {: RESULT = new Sequence<Statement>(s)                              ;:}
;

// Sequence[LocalDecl <: Statement] <: AST
local_variable_declaration
::=
    CONST
    type:t
    variable_declarators:v              {: Sequence<LocalDeclaration> s = new Sequence<LocalDeclaration>();
                                           for(int index = 0; index < ((Sequence<LocalDeclaration>) v).size(); index++) {

                                                // Initialize  a handle to the LocalDeclaration
                                                final LocalDeclaration localDeclaration = (LocalDeclaration) v.child(index);

                                                s.append(new LocalDeclaration(t, localDeclaration.getName(),
                                                    localDeclaration.getInitializationExpression(), true /* it is CONST */));

                                           }

                                           RESULT = s                                                       ;:}
|   type:t
    variable_declarators:v              {: Sequence s = new Sequence<LocalDeclaration>();
                                           for(int index = 0; index < ((Sequence<LocalDeclaration>) v).size(); index++) {
                                                // Initialize  a handle to the LocalDeclaration
                                                final LocalDeclaration localDeclaration = (LocalDeclaration) v.child(index);
                                                s.append(new LocalDeclaration(t, localDeclaration.getName(),
                                                    localDeclaration.getInitializationExpression(), false /* it is not CONST */));

                                           }

                                           RESULT = s                                                       ;:}
|   MOBILE
    type:t
    variable_declarators:v              {: Sequence s = new Sequence<LocalDeclaration>();
                                           for(int index = 0; index < ((Sequence<LocalDeclaration>) v).size(); index++) {
                                                // Initialize  a handle to the LocalDeclaration
                                                final LocalDeclaration localDeclaration = (LocalDeclaration) v.child(index);
                                                s.append(new LocalDeclaration(t, localDeclaration.getName(),
                                                    localDeclaration.getInitializationExpression(), false /* it is not CONST */));

                                           }

                                           RESULT = s                                                       ;:}
;
// TODO: we should be able to declare mobile channels and procedures here

// Statement <: AST
statement
::=
    statement_without_trailing_substatement:s   {: RESULT = s                                               ;:}
|   if_then_statement:s                         {: RESULT = s                                               ;:}
|   if_then_else_statement:s                    {: RESULT = s                                               ;:}
|   while_statement:s                           {: RESULT = s                                               ;:}
|   for_statement:s                             {: RESULT = s                                               ;:}
|   claim_statement:s                           {: RESULT = s                                               ;:}
|   labeled_statement:s                         {: RESULT = s                                               ;:}
;

// Statement <: AST
statement_no_short_if
::=
    statement_without_trailing_substatement:s   {: RESULT = s                                               ;:}
|   if_then_else_statement_no_short_if:s        {: RESULT = s                                               ;:}
|   while_statement_no_short_if:s               {: RESULT = s                                               ;:}
|   for_statement_no_short_if:s                 {: RESULT = s                                               ;:}
|   claim_statement_no_short_if:s               {: RESULT = s                                               ;:}
;

// Statement <: AST
statement_without_trailing_substatement
::=
    block:s                                     {: RESULT = s                                                   ;:}
|   par_block:s                                 {: RESULT = s                                                   ;:}
|   empty_statement:s                           {: RESULT = s                                                   ;:}
|   do_statement:s                              {: RESULT = s                                                   ;:}
|   barrier_sync_statement:s                    {: RESULT = s                                                   ;:}
|   timeout_statement:s SEMICOLON               {: RESULT = s                                                   ;:}
|   SEQ block:s                                 {: RESULT = s                                                   ;:}
|   suspend_statement:s                         {: RESULT = s                                                   ;:}
|   expression_statement:s                      {: RESULT = s                                                   ;:}
|   break_statement:s                           {: RESULT = s                                                   ;:}
|   continue_statement:s                        {: RESULT = s                                                   ;:}
|   return_statement:s                          {: RESULT = s                                                   ;:}
|   switch_statement:s                          {: RESULT = s                                                   ;:}
|   skip_statement:s                            {: RESULT = s                                                   ;:}
|   stop_statement:s                            {: RESULT = s                                                   ;:}
|   IDENTIFIER:id
    DOT
    WRITE
    LPAREN
    expression:e
    RPAREN
    SEMICOLON                                   {: RESULT = new ChannelWriteStatement(new NameExpression(new Name(id)), e) ;:}
|   primary:p
    DOT
    WRITE
    LPAREN
    expression:e
    RPAREN
    SEMICOLON                                   {: RESULT = new ChannelWriteStatement(p, e)                     ;:}
|   alt_statement:s                             {: RESULT = s                                                   ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 9.1 If statements                                                                                               **/
/** --------------------------------------------------------------------------------------------------------------- **/

// IfStat <: Statement <: AST
if_then_statement
::=
    IF
    LPAREN
    expression:e
    RPAREN
    statement:s                                 {: RESULT = new IfStatement(e, s, null)                              ;:}
//|   IF
//    LPAREN
//    error
//    RPAREN
//    statement                                 {: printf("Error in if expression\n"); RESULT = NULL            ;:}
//|   IF
//    error
//    expression
//    RPAREN
//    statement                                 {: printf("Missing ( in if statement\n"); RESULT = NULL         ;:}
//|   IF
//    LPAREN
//    expression
//    error
//    statement                                 {: printf("Missing ) in if statement\n"); RESULT = NULL         ;:}
;

// IfStat <: Statement <: AST
if_then_else_statement
::=
    IF
    LPAREN
    expression:e
    RPAREN
    statement_no_short_if:s1
    ELSE
    statement:s2                                {: RESULT = new IfStatement(e, s1, s2)                         ;:}
;

// IfStat <: Statement <: AST
if_then_else_statement_no_short_if
::=
    IF
    LPAREN
    expression:e
    RPAREN
    statement_no_short_if:s1
    ELSE statement_no_short_if:s2               {: RESULT = new IfStatement(e, s1, s2)                        ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 9.2 While/For/Do statement                                                                                      **/
/** --------------------------------------------------------------------------------------------------------------- **/

// WhileStat <: Statement <: AST
while_statement
::=
    WHILE
    LPAREN
    expression:e
    RPAREN
    statement:s                                 {: RESULT = new WhileStatement(e, s)                                 ;:}
;

// WhileStat <: Statement <: AST
while_statement_no_short_if
::=
    WHILE
    LPAREN
    expression:e
    RPAREN
    statement_no_short_if:s                     {: RESULT = new WhileStatement(e, s)                                 ;:}
;

// ForStat <: Statement <: AST
for_statement
::=
    FOR:t
    LPAREN
    for_init_opt:i
    SEMICOLON
    expression_opt:e
    SEMICOLON
    for_update_opt:u
    RPAREN
    statement:s                                 {: RESULT = new ForStatement(t, i, e, u, new Sequence<Expression>(), s, false)   ;:}
|   PAR
    FOR:t
    LPAREN
    for_init_opt:i
    SEMICOLON
    expression_opt:e
    SEMICOLON
    for_update_opt:u
    RPAREN
    ENROLL
    LPAREN
    argument_list:b
    RPAREN
    statement:s                                 {: RESULT = new ForStatement(t, i, e, u, b, s, true)             ;:}
|   PAR
    FOR:t
    LPAREN
    for_init_opt:i
    SEMICOLON
    expression_opt:e
    SEMICOLON
    for_update_opt:u
    RPAREN
    statement:s                                 {: RESULT = new ForStatement(t, i, e, u, new Sequence<Expression>(), s, true)    ;:}
;

// ForStat <: Statement <: AST
for_statement_no_short_if
::=
    FOR:t
    LPAREN
    for_init_opt:i
    SEMICOLON
    expression_opt:e
    SEMICOLON
    for_update_opt:u
    RPAREN
    statement_no_short_if:s                     {: RESULT = new ForStatement(t, i, e, u, new Sequence<Expression>(), s, false)   ;:}
|   PAR
    FOR:t
    LPAREN
    for_init_opt:i
    SEMICOLON
    expression_opt:e
    SEMICOLON
    for_update_opt:u
    RPAREN
    ENROLL
    LPAREN
    argument_list:b
    RPAREN
    statement_no_short_if:s                     {: RESULT = new ForStatement(t, i, e, u, b, s, true)             ;:}
|   PAR
    FOR:t
    LPAREN
    for_init_opt:i
    SEMICOLON
    expression_opt:e
    SEMICOLON
    for_update_opt:u
    RPAREN
    statement_no_short_if:s                     {: RESULT = new ForStatement(t, i, e, u, new Sequence<Expression>(), s, true)    ;:}
;

// Sequence[AST] <: AST
for_init_opt
::=
    for_init:i                                  {: RESULT = i                                                       ;:}
|   /* Epsilon */                               {: RESULT = new Sequence<AST>()                                     ;:}
;

// Sequence[AST] <: AST
for_init
::=
    statement_expressions:e                     {: RESULT = e                                                       ;:}
|   local_variable_declaration:e                {: RESULT = e                                                       ;:}
;

// Sequence[ExprStat <: AST] <: AST
for_update_opt
::=
    for_update:u                                {: RESULT = u                                                       ;:}
|   /* Epsilon */                               {: RESULT = new Sequence<ExpressionStatement>()                     ;:}
;

// Sequence[ExprStat <: AST] <: AST
for_update
::=
    statement_expressions:s                     {: RESULT = s                                                       ;:}
;

// Sequence[ExprStat <: AST] <: AST
statement_expressions
::=
    statement_expression:e                      {: RESULT = new Sequence<ExpressionStatement>(new ExpressionStatement(e))                 ;:}
|   statement_expressions:lst
    COMMA
    statement_expression:e                      {: RESULT = lst.append(new ExpressionStatement(e))                             ;:}
;

// DoStat <: Statement <: AST
do_statement
::=
    DO
    statement:s
    WHILE
    LPAREN
    expression:e
    RPAREN
    SEMICOLON                                   {: RESULT = new DoStatement(s, e)                                    ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 9.3 Claim Statement                                                                                             **/
/** --------------------------------------------------------------------------------------------------------------- **/

// ClaimStat <: Statement <: AST
claim_statement
::=
    CLAIM
    LPAREN
    channels:c
    RPAREN
    statement:s                                 {: RESULT = new ClaimStatement(c, s)                                ;:}
;

// ClaimStat <: Statement <: AST
claim_statement_no_short_if ::=
    CLAIM
    LPAREN
    channels:c
    RPAREN
    statement_no_short_if:s                     {: RESULT = new ClaimStatement(c, s)                                ;:}
;

// Sequence[AST] <: AST
channels
::=
    channels:lst
    COMMA
    channel:e                                   {: RESULT = lst.append(e)                                           ;:}
|   channel:e                                   {: RESULT = new Sequence<AST>(e)                                    ;:}
;

// AST
channel
::=
    IDENTIFIER:id                               {: RESULT = new NameExpression(new Name(id))                        ;:}
|   channel_type:t
    IDENTIFIER:id
    EQ
    primary_no_new_array_or_mobile:e            {: RESULT = new LocalDeclaration(t, new Name(id), e, false) ;:}
|   chan_expression:e                           {: RESULT = e                                                        ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 9.4 Empty Statement                                                                                             **/
/** --------------------------------------------------------------------------------------------------------------- **/

// Statement <: AST
empty_statement
::=
    SEMICOLON                                   {: RESULT = null                                                    ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 9.5 Barrier Synch/Timeout Statement                                                                             **/
/** --------------------------------------------------------------------------------------------------------------- **/

// SyncStat <: Statement <: AST
barrier_sync_statement
::=
// SYNC
// primary_no_new_array_or_mobile:e
// SEMICOLON                                    {: RESULT = new SyncStatement(e)                                    ;:}
    primary:e
    DOT
    SYNC
    LPAREN
    RPAREN
    SEMICOLON                                   {: RESULT = new SyncStatement(e)                                    ;:}
|   IDENTIFIER:id
    DOT
    SYNC
    LPAREN
    RPAREN
    SEMICOLON                                   {: RESULT = new SyncStatement(new NameExpression(new Name(id)))           ;:}
;

// TimeoutStat <: Statement <: AST
timeout_statement
::=
    IDENTIFIER:id
    DOT
    TIMEOUT
    LPAREN
    expression:e
    RPAREN                                      {: RESULT = new TimeoutStatement(new NameExpression(new Name(id)), e)     ;:}
|   primary:p
    DOT
    TIMEOUT
    LPAREN
    expression:e
    RPAREN                                      {: RESULT = new TimeoutStatement(p, e)                              ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 9.6 Suspend Statement                                                                                           **/
/** --------------------------------------------------------------------------------------------------------------- **/

// SuspendStat <: Statement <: AST
suspend_statement
::=
    SUSPEND:s
    SEMICOLON                                   {: RESULT = new SuspendStatement(s, new Sequence())                 ;:}
    //SUSPEND:s
    //RESUME
    //WITH
    //LPAREN
    //formal_parameter_list:l
    //RPAREN
    //SEMICOLON                                 {: RESULT = new SuspendStatement(s, l)                              ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 9.7 Expression Statement                                                                                        **/
/** --------------------------------------------------------------------------------------------------------------- **/

// ExprStat <: AST
expression_statement
::=
    statement_expression:e
    SEMICOLON                          {: RESULT = new ExpressionStatement(e)                                      ;:}
;

// Expression <: AST
statement_expression
::=
    assignment:e                                 {: RESULT = e                                                    ;:}
|   pre_increment_expression:e                   {: RESULT = e                                                    ;:}
|   pre_decrement_expression:e                   {: RESULT = e                                                    ;:}
|   post_increment_expression:e                  {: RESULT = e                                                    ;:}
|   post_decrement_expression:e                  {: RESULT = e                                                    ;:}
|   invocation_expression:e                      {: RESULT = e                                                    ;:}
|   primary:p
    DOT
    READ
    LPAREN
    block_opt:b
    RPAREN                              {: RESULT = new ChannelReadExpression(p, b)                           ;:}
|   IDENTIFIER:id
    DOT
    READ
    LPAREN
    block_opt:b
    RPAREN                              {: RESULT = new ChannelReadExpression(new NameExpression(new Name(id)), b)  ;:}
;

// Statement <: AST
labeled_statement
::=
    IDENTIFIER:id
    COLON
    statement:s                         {: s.setLabel(id.lexeme); RESULT = s                            ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 9.8 Break/Continue/Return Statement                                                                             **/
/** --------------------------------------------------------------------------------------------------------------- **/

// BreakStat <: Statement <: AST
break_statement
::=
    BREAK:b
    identifier_opt:i
    SEMICOLON                           {: RESULT = new BreakStatement(b, i)                                 ;:}
;

// ContinueStat <: Statement <: AST
continue_statement
::=
    CONTINUE:c
    identifier_opt:i
    SEMICOLON                           {: RESULT = new ContinueStatement(c,i)                               ;:}
;

// Name <: AST
identifier_opt
::=
    IDENTIFIER:id                       {: RESULT = new Name(id)                                        ;:}
|   /* Epsilon */                       {: RESULT = null                                                ;:}
;

// ReturnStat <: Statement <: AST
return_statement
::=
    RETURN:r
    expression_opt:e
    SEMICOLON                           {: RESULT = new ReturnStatement(r, e)                                ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 9.9 Switch Statement                                                                                            **/
/** --------------------------------------------------------------------------------------------------------------- **/

// SwitchStat <: Statement <: AST
switch_statement
::=
    SWITCH
    LPAREN
    expression:e
    RPAREN
    switch_block:b                      {: RESULT = new SwitchStatement(e, b)                                ;:}
;

// Sequence<SwitchGroup <: AST> <: AST
switch_block
::=
    LBRACE
    switch_block_statement_groups_opt:s
    RBRACE                              {: RESULT = s                                                   ;:}
;

// Sequence<SwitchGroup <: AST> <: AST
switch_block_statement_groups_opt
::=
    switch_block_statement_groups:s     {: RESULT = s                                                   ;:}
|   /* Epsilon */                       {: RESULT = new Sequence<SwitchGroupStatement>()                ;:}
;

// Sequence<SwitchGroup <: AST> <: AST
switch_block_statement_groups
::=
    switch_block_statement_group:e      {: RESULT = new Sequence<SwitchGroupStatement>(e)               ;:}
|   switch_block_statement_groups:lst
    switch_block_statement_group:e      {: RESULT = lst.append(e)                                       ;:}
;

// SwitchGroup <: AST
switch_block_statement_group
::=
    switch_labels:s
    block_statements:b                  {: RESULT = new SwitchGroupStatement(s, b)                      ;:}
;

// Sequence<SwitchLabel <: AST> <: AST
switch_labels
::=
    switch_label:e                      {: RESULT = new Sequence<SwitchLabel>(e)                        ;:}
|   switch_labels:lst
    switch_label:e                      {: RESULT = lst.append(e)                                       ;:}
;

// SwitchLabel <: AST
switch_label
::=
    CASE
    constant_expression:e
    COLON                               {: RESULT = new SwitchLabel(e, false /* not default: */)        ;:}
|   DEFAULT
    COLON                               {: RESULT = new SwitchLabel(null, true /* default: */)          ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 9.10 Skip/Stop Statement                                                                                        **/
/** --------------------------------------------------------------------------------------------------------------- **/

// StopStat <: Statement <: AST
stop_statement
::=
    STOP:s
    SEMICOLON                           {: RESULT = new StopStatement(s)                                 ;:}
;

// SkipStat <: Statement <: AST
skip_statement
::=
    SKIP:s
    SEMICOLON                           {: RESULT = new SkipStatement(s)                                 ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 9.11 Alt Statement                                                                                              **/
/** --------------------------------------------------------------------------------------------------------------- **/

// AltStat <: AST
alt_statement
::=
    PRI
    ALT
    LBRACE
    alt_body:b
    RBRACE                              {: RESULT = new AltStatement(b, true /* PRI ALT */)               ;:}
|   PRI
    ALT
    LPAREN
    for_init_opt:i
    SEMICOLON
    expression_opt:e
    SEMICOLON
    for_update_opt:u
    RPAREN
    LBRACE
    alt_body:b
    RBRACE                              {: RESULT = new AltStatement(i, e, u, b, true /* PRI ALT */)      ;:}
|   ALT
    LBRACE
    alt_body:b
    RBRACE                              {: RESULT = new AltStatement(b, false /* ALT */)                  ;:}
|   ALT
    LPAREN
    for_init_opt:i
    SEMICOLON
    expression_opt:e
    SEMICOLON
    for_update_opt:u
    RPAREN
    LBRACE
    alt_body:b
    RBRACE                              {: RESULT = new AltStatement(i, e, u, b, false /* ALT */)         ;:}
;

// Sequence[AltCase <: AST] <: AST
alt_body
::=
    alt_body:lst
    alt_case:e                          {: RESULT = lst.append(e)                                       ;:}
|   alt_case:e                          {: RESULT = new Sequence<AltCase>(e)                            ;:}
;

// AltCase <: AST
alt_case
::=
    LPAREN
    expression:e
    RPAREN
    ANDAND
    guardStatement:g
    COLON
    statement:s                         {: RESULT = new AltCase(e, g, s)                                ;:}
|   guardStatement:g
    COLON
    statement:s                         {: RESULT = new AltCase(null, g, s)                             ;:}
|   alt_statement:as                    {: RESULT = new AltCase(as)                                     ;:}
;

// Guard (takes in a statement) <: AST
guardStatement
::=
    left_hand_side:l
    EQ
    chan_read_expression:e              {: RESULT = new GuardStatement(new ExpressionStatement(new AssignmentExpression(l, e, AssignmentExpression.EQ))) ;:}
|   SKIP:s                              {: RESULT = new GuardStatement(new SkipStatement(s))                                      ;:}
|   timeout_statement:s                 {: RESULT = new GuardStatement(s)                                                    ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 10.0 Expressions                                                                                                **/
/** --------------------------------------------------------------------------------------------------------------- **/

// constants: array, record, protocol
// Expression <: AST
primary
::=
    primary_no_new_array_or_mobile:e    {: RESULT = e                                                   ;:}
|   array_creation_expression:e         {: RESULT = e                                                   ;:}
|   mobile_creation:e                   {: RESULT = e                                                   ;:}
|   chan_read_expression:e              {: RESULT = e                                                   ;:}
|   chan_expression:e                   {: RESULT = e                                                   ;:}
|   primary:e
    COLONCOLON
    IDENTIFIER:id                       {: RESULT = new NameExpression(new Name(id, primary2PackageAccess(e)))      ;:}
|   IDENTIFIER:id1
    COLONCOLON
    IDENTIFIER:id2                      {: RESULT = new NameExpression(new Name(id2, new Sequence(new Name(id1))))  ;:}
;

// Expression <: AST
primary_no_new_array_or_mobile
::=
    literal:e                           {: RESULT = e                                                   ;:}
|   LPAREN expression:e RPAREN          {: RESULT = e; RESULT.hasParens = true                          ;:}
|   record_access:e                     {: RESULT = e                                                   ;:}
|   invocation_expression:e             {: RESULT = e                                                   ;:}
|   array_access:e                      {: RESULT = e                                                   ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 10.1 Array Creation Expressions                                                                                 **/
/** --------------------------------------------------------------------------------------------------------------- **/

// NewArray <: Expression <: AST
array_creation_expression
::=
    NEW
    primitive_type:t
    dim_exprs:d1
    dims_opt:d2                         {: RESULT = new NewArrayExpression(t, d1, d2, null)                           ;:}
|   NEW
    primitive_type:t
    dims:d
    array_initializer:i                 {: RESULT = new NewArrayExpression(t, new Sequence<Expression>(), d, i)       ;:}
|   NEW
    IDENTIFIER:id
    dim_exprs:d1
    dims_opt:d2                         {: RESULT = new NewArrayExpression(new NamedType(new Name(id)), d1, d2, null) ;:}
|   NEW
    IDENTIFIER:id
    dims:d
    array_initializer:i                 {: RESULT = new NewArrayExpression(new NamedType(new Name(id)), new Sequence<Expression>(), d, i) ;:}
|   NEW
    channel_type:ct
    dim_exprs:d1
    dims_opt:d2                         {: RESULT = new NewArrayExpression(ct, d1, d2, null)                          ;:}
|   NEW
    channel_type:ct
    dims:d
    array_initializer:i                 {: RESULT = new NewArrayExpression(ct, new Sequence<Expression>(), d, i)      ;:}
;

// Sequence[Expression <: AST] <: AST
dim_exprs
::=
    dim_expr:e                          {: RESULT = new Sequence<Expression>(e)                             ;:}
|   dim_exprs:lst
    dim_expr:e                          {: RESULT = lst.append(e)                                           ;:}
;

// Expression <: AST
dim_expr
::=
    LBRACK
    expression:e
    RBRACK                              {: RESULT = e                                                       ;:}
;

// Sequence[NULL] <: AST
dims_opt
::=
    dims:d                              {: RESULT = d                                                       ;:}
|   /* Epsilon */                       {: RESULT = new Sequence<AST>()                                     ;:}
;

// Sequence<NULL> <: AST
dims
::=
    dims:lst
    LBRACK
    RBRACK                              {: RESULT = lst.append(null)                                        ;:}
|   LBRACK
    RBRACK                              {: RESULT = new Sequence<AST>(null)                                 ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 10.2 Mobile Creation Expression                                                                                 **/
/** --------------------------------------------------------------------------------------------------------------- **/

// NewMobile <: Expression <: AST
mobile_creation
::=
    NEW
    MOBILE
    LPAREN
    type_name:tn
    RPAREN                              {: RESULT = new NewMobileExpression(tn)                                     ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 10.3 Channel Expression/Channel Read Expression                                                                 **/
/** --------------------------------------------------------------------------------------------------------------- **/

// ChannelEndExpression <: Expression <: AST
chan_expression
::=
    primary:p
    DOT
    READ                                {: RESULT = new ChannelEndExpression(p, ChannelEndExpression.READ)              ;:}
|   primary:p
    DOT
    WRITE                               {: RESULT = new ChannelEndExpression(p, ChannelEndExpression.WRITE)             ;:}
|   IDENTIFIER:id
    DOT
    READ                                {: RESULT = new ChannelEndExpression(new NameExpression(new Name(id)), ChannelEndExpression.READ) ;:}
|   IDENTIFIER:id
    DOT
    WRITE                               {: RESULT = new ChannelEndExpression(new NameExpression(new Name(id)), ChannelEndExpression.WRITE);:}
;

// ChannelReadExpr <: Expression <: AST
chan_read_expression
::=
    primary:p
    DOT
    READ
    LPAREN
    block_opt:b
    RPAREN                              {: RESULT = new ChannelReadExpression(p, b)                                 ;:}
|   IDENTIFIER:id
    DOT
    READ
    LPAREN
    block_opt:b
    RPAREN                              {: RESULT = new ChannelReadExpression(new NameExpression(new Name(id)), b)  ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 10.4 Structure Access                                                                                           **/
/** --------------------------------------------------------------------------------------------------------------- **/

// Expression <: AST
record_access
::=
    primary:p
    DOT
    IDENTIFIER:id                       {: RESULT = new RecordAccessExpression(p, new Name(id))                             ;:}
|   IDENTIFIER:id1
    DOT
    IDENTIFIER:id2                      {: RESULT = new RecordAccessExpression(new NameExpression(new Name(id1)), new Name(id2))  ;:}
;

// ArrayAccessExpr <: Expression <: AST
array_access
::=
    IDENTIFIER:id
    LBRACK
    expression:e
    RBRACK                              {: RESULT = new ArrayAccessExpression(new NameExpression(new Name(id)), e)        ;:}
|   primary_no_new_array_or_mobile:p
    LBRACK
    expression:e
    RBRACK                              {: RESULT = new ArrayAccessExpression(p, e)                                 ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 10.5 Invocation Expression                                                                                      **/
/** --------------------------------------------------------------------------------------------------------------- **/

// Invocation <: Expression <: AST
invocation_expression
::=
    IDENTIFIER:id
    LPAREN
    argument_list_opt:l
    RPAREN                              {: RESULT = new InvocationExpression(null, new Name(id), l)               ;:}
|   FORK:f
    LPAREN
    argument_list:l
    RPAREN                              {: RESULT = new InvocationExpression(null, new Name(f), l)                ;:}
|   primary:p
    DOT
    IDENTIFIER:id
    LPAREN
    argument_list_opt:l
    RPAREN                              {: RESULT = new InvocationExpression(p, new Name(id), l)                  ;:}
|   primary:p
    COLONCOLON
    IDENTIFIER:id
    LPAREN
    argument_list_opt:l
    RPAREN                              {: RESULT = new InvocationExpression(null, new Name(id, primary2PackageAccess(p)), l) ;:}
|   IDENTIFIER:p
    COLONCOLON
    IDENTIFIER:id
    LPAREN
    argument_list_opt:l
    RPAREN                              {: RESULT = new InvocationExpression(null, new Name(id,
                                                        primary2PackageAccess(new NameExpression(new Name(p)))), l) ;:}
|   IDENTIFIER:p
    DOT
    IDENTIFIER:id
    LPAREN
    argument_list_opt:l
    RPAREN                              {: RESULT = new InvocationExpression(new NameExpression(new Name(p)), new Name(id), l)      ;:}
;

// Sequence[Expression <: AST] <: AST
argument_list_opt
::=
    argument_list:a                     {: RESULT = a                                                               ;:}
|   /* Epsilon */                       {: RESULT = new Sequence<Expression>()                                      ;:}
;

// Sequence[Expression <: AST] <: AST
argument_list
::=
    expression:e                        {: RESULT = new Sequence<Expression>(e)                                     ;:}
|   argument_list:lst
    COMMA
    expression:e                        {: RESULT = lst.append(e)                                                   ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 10.6 Other Expressions                                                                                          **/
/** --------------------------------------------------------------------------------------------------------------- **/

// Expression <: AST
postfix_expression
::=
    primary:e                           {: RESULT = e                                                               ;:}
|   post_increment_expression:e         {: RESULT = e                                                               ;:}
|   post_decrement_expression:e         {: RESULT = e                                                               ;:}
|   IDENTIFIER:id                       {: RESULT = new NameExpression(new Name(id))                                ;:}
;

// UnaryPostExpression <: Expression <: AST
post_increment_expression
::=
    postfix_expression:e
    PLUSPLUS                            {: RESULT = new UnaryPostExpression(e, UnaryPostExpression.PLUSPLUS)                    ;:}
;

// UnaryPostExpression <: Expression <: AST
post_decrement_expression
::=
    postfix_expression:e
    MINUSMINUS                          {: RESULT = new UnaryPostExpression(e, UnaryPostExpression.MINUSMINUS)                  ;:}
;

// Expression <: AST
unary_expression
::=
    pre_increment_expression:e          {: RESULT = e                                                               ;:}
|   pre_decrement_expression:e          {: RESULT = e                                                               ;:}
|   PLUS unary_expression:e             {: RESULT = e                                                               ;:}
|   MINUS unary_expression:e            {: RESULT = new UnaryPreExpression(e, UnaryPreExpression.MINUS)                   ;:}
|   unary_expression_not_plus_minus:e   {: RESULT = e                                                               ;:}
;

// UnaryPreExpr <: Expression <:  AST
pre_increment_expression
::=
    PLUSPLUS
    unary_expression:e                  {: RESULT = new UnaryPreExpression(e, UnaryPreExpression.PLUSPLUS)               ;:}
;

// UnaryPreExpr <: Expression <: AST
pre_decrement_expression
::=
    MINUSMINUS
    unary_expression:e                  {: RESULT = new UnaryPreExpression(e, UnaryPreExpression.MINUSMINUS)              ;:}
;

// Expression <: AST
unary_expression_not_plus_minus
::=
    postfix_expression:e                {: RESULT = e                                                               ;:}
|   COMP unary_expression:e             {: RESULT = new UnaryPreExpression(e, UnaryPreExpression.COMP)              ;:}
|   NOT unary_expression:e              {: RESULT = new UnaryPreExpression(e, UnaryPreExpression.NOT)               ;:}
|   cast_expression:e                   {: RESULT = e                                                               ;:}
;
             
// CastExpr <: Expression <: AST
cast_expression
::=
    LPAREN
    expression:e
    RPAREN
    unary_expression_not_plus_minus:ex  {: if(e instanceof NameExpression)
                                               RESULT = new CastExpression(new NamedType(((NameExpression) e).getName()), ex);
                                           else {
                                               handler.onIllegalCastExpression(e,
                                                    Lexer.CurrentLine.length() + 1, Lexer.LineCount);
                                               RESULT = null;
                                           }                                                                         :}
|   LPAREN
    primitive_type:t
    RPAREN
    unary_expression:e                  {: RESULT = new CastExpression(t, e)                                        ;:}
;

// Expression <: AST
multiplicative_expression
::=
    unary_expression:e                  {: RESULT = e                                                               ;:}
|   multiplicative_expression:e1
    MULT
    unary_expression:e2                 {: RESULT = new BinaryExpression(e1, e2, BinaryExpression.MULT)             ;:}
|   multiplicative_expression:e1
    DIV
    unary_expression:e2                 {: RESULT = new BinaryExpression(e1, e2, BinaryExpression.DIV)              ;:}
|   multiplicative_expression:e1
    MOD
    unary_expression:e2                 {: RESULT = new BinaryExpression(e1, e2, BinaryExpression.MOD)              ;:}
;

// Expression <: AST
additive_expression
::=
    multiplicative_expression:e         {: RESULT = e                                                               ;:}
|   additive_expression:e1
    PLUS
    multiplicative_expression:e2        {: RESULT = new BinaryExpression(e1, e2, BinaryExpression.PLUS)             ;:}
|   additive_expression:e1
    MINUS
    multiplicative_expression:e2        {: RESULT = new BinaryExpression(e1, e2, BinaryExpression.MINUS)            ;:}
;

// Expression <: AST
shift_expression
::=
    additive_expression:e               {: RESULT = e                                                               ;:}
|   shift_expression:e1
    LSHIFT
    additive_expression:e2              {: RESULT = new BinaryExpression(e1, e2, BinaryExpression.LSHIFT)           ;:}
|   shift_expression:e1
    RSHIFT
    additive_expression:e2              {: RESULT = new BinaryExpression(e1, e2, BinaryExpression.RSHIFT)           ;:}
|   shift_expression:e1
    RRSHIFT
    additive_expression:e2              {: RESULT = new BinaryExpression(e1, e2, BinaryExpression.RRSHIFT)          ;:}
;
                       
// Expression <: AST
relational_expression
::=
    shift_expression:e                  {: RESULT = e                                                               ;:}
|   relational_expression:e1
    LT
    shift_expression:e2                 {: RESULT = new BinaryExpression(e1, e2, BinaryExpression.LT)               ;:}
|   relational_expression:e1
    GT
    shift_expression:e2                 {: RESULT = new BinaryExpression(e1, e2, BinaryExpression.GT)               ;:}
|   relational_expression:e1
    LTEQ
    shift_expression:e2                 {: RESULT = new BinaryExpression(e1, e2, BinaryExpression.LTEQ)             ;:}
|   relational_expression:e1
    GTEQ
    shift_expression:e2                 {: RESULT = new BinaryExpression(e1, e2, BinaryExpression.GTEQ)             ;:}
|   relational_expression:e1
    IS
    type_name:e2                        {: RESULT = new BinaryExpression(e1, new NameExpression(e2), BinaryExpression.INSTANCEOF);:}
;
             
// Expression <: AST
equality_expression
::=
    relational_expression:e             {: RESULT = e                                                               ;:}
|   equality_expression:e1
    EQEQ
    relational_expression:e2            {: RESULT = new BinaryExpression(e1, e2, BinaryExpression.EQEQ)             ;:}
|   equality_expression:e1
    NOTEQ
    relational_expression:e2            {: RESULT = new BinaryExpression(e1, e2, BinaryExpression.NOTEQ)            ;:}
;
             
// Expression <: AST
and_expression
::=
    equality_expression:e               {: RESULT = e                                                               ;:}
|   and_expression:e1
    AND
    equality_expression:e2              {: RESULT = new BinaryExpression(e1 ,e2, BinaryExpression.AND)                          ;:}
;
             
// Expression <: AST
exclusive_or_expression
::=
    and_expression:e                    {: RESULT = e                                                               ;:}
|   exclusive_or_expression:e1
    XOR
    and_expression:e2                   {: RESULT = new BinaryExpression(e1 ,e2, BinaryExpression.XOR)                          ;:}
;
             
// Expression <: AST
inclusive_or_expression
::=
    exclusive_or_expression:e           {: RESULT = e                                                               ;:}
|   inclusive_or_expression:e1
    OR
    exclusive_or_expression:e2          {: RESULT = new BinaryExpression(e1 ,e2 ,BinaryExpression.OR)                           ;:}
;
            
// Expression <: AST
conditional_and_expression
::=
    inclusive_or_expression:e           {: RESULT = e                                                               ;:}
|   conditional_and_expression:e1
    ANDAND
    inclusive_or_expression:e2          {: RESULT = new BinaryExpression(e1 ,e2, BinaryExpression.ANDAND)                       ;:}
;
             
// Expression <: AST
conditional_or_expression
::=
    conditional_and_expression:e        {: RESULT = e                                                               ;:}
|   conditional_or_expression:e1
    OROR
    conditional_and_expression:e2       {: RESULT = new BinaryExpression(e1, e2, BinaryExpression.OROR)                         ;:}
;
             
// Expression <: AST
conditional_expression
::=
    conditional_or_expression:e         {: RESULT = e                                                               ;:}
|   conditional_or_expression:e
    QUEST
    expression:e1
    COLON
    conditional_expression:e2           {: RESULT = new TernaryExpression(e ,e1, e2)                                ;:}
;
             
// Expression <: AST
assignment_expression
::=
    conditional_expression:e            {: RESULT = e                                                               ;:}
|   assignment:a                        {: RESULT = a                                                               ;:}
;

// Assignment <: Expression <: AST
assignment
::=
    left_hand_side:l
    assignment_operator:o
    assignment_expression:e             {: RESULT = new AssignmentExpression(l, e, o)                                ;:}
;
             
// Integer
assignment_operator
::=
    EQ                                  {: RESULT = AssignmentExpression.EQ                                                   ;:}
|   MULTEQ                              {: RESULT = AssignmentExpression.MULTEQ                                               ;:}
|   DIVEQ                               {: RESULT = AssignmentExpression.DIVEQ                                                ;:}
|   MODEQ                               {: RESULT = AssignmentExpression.MODEQ                                                ;:}
|   PLUSEQ                              {: RESULT = AssignmentExpression.PLUSEQ                                               ;:}
|   MINUSEQ                             {: RESULT = AssignmentExpression.MINUSEQ                                              ;:}
|   LSHIFTEQ                            {: RESULT = AssignmentExpression.LSHIFTEQ                                             ;:}
|   RSHIFTEQ                            {: RESULT = AssignmentExpression.RSHIFTEQ                                             ;:}
|   RRSHIFTEQ                           {: RESULT = AssignmentExpression.RRSHIFTEQ                                            ;:}
|   ANDEQ                               {: RESULT = AssignmentExpression.ANDEQ                                                ;:}
|   XOREQ                               {: RESULT = AssignmentExpression.XOREQ                                                ;:}
|   OREQ                                {: RESULT = AssignmentExpression.OREQ                                                 ;:}
;
       
// Expression <: AST
left_hand_side
::=
    IDENTIFIER:id                       {: RESULT = new NameExpression(new Name(id))                                ;:}  // TODO - not really a nameExpr .... but oh well
|   record_access:r                     {: RESULT = r                                                               ;:}
|   array_access:a                      {: RESULT = a                                                               ;:}
;
        
// Expression <: AST
expression_opt
::=
    expression:e                        {: RESULT = e                                                               ;:}
|   /* Epsilon */                       {: RESULT = null                                                            ;:}
;

// Expression <: AST
expression
::=
    assignment_expression:e             {: RESULT = e                                                               ;:}
;

// Expression <: AST
constant_expression ::=
    expression:e                        {: RESULT = e                                                               ;:}
;

/** --------------------------------------------------------------------------------------------------------------- **/
/** 11.0 Literals                                                                                                   **/
/** --------------------------------------------------------------------------------------------------------------- **/

// Literal is a super class for : PrimitiveLiteral, RecordLiteral, ProtocolLiteral and ArrayLiteral
// Literal <: Expression <: AST
literal
::=
    INTEGER_LITERAL:l                   {: RESULT = new PrimitiveLiteralExpression(l, PrimitiveLiteralExpression.IntKind)               ;:}
|   LONG_LITERAL:l                      {: RESULT = new PrimitiveLiteralExpression(l, PrimitiveLiteralExpression.LongKind)              ;:}
|   FLOAT_LITERAL:l                     {: RESULT = new PrimitiveLiteralExpression(l, PrimitiveLiteralExpression.FloatKind)             ;:}
|   DOUBLE_LITERAL:l                    {: RESULT = new PrimitiveLiteralExpression(l, PrimitiveLiteralExpression.DoubleKind)            ;:}
|   BOOLEAN_LITERAL:l                   {: RESULT = new PrimitiveLiteralExpression(l, PrimitiveLiteralExpression.BooleanKind)           ;:}
|   STRING_LITERAL:l                    {: RESULT = new PrimitiveLiteralExpression(l, PrimitiveLiteralExpression.StringKind)            ;:}
|   CHARACTER_LITERAL:l                 {: RESULT = new PrimitiveLiteralExpression(l, PrimitiveLiteralExpression.CharKind)              ;:}
|   record_literal:l                    {: RESULT = l                                                               ;:}
|   protocol_literal:l                  {: RESULT = l                                                               ;:}
|   NULL_LITERAL:l                      {: RESULT = new PrimitiveLiteralExpression(l, PrimitiveLiteralExpression.NullKind)              ;:}
;

// RecordLiteral <: Literal <: Expression <: AST
record_literal
::=
    NEW
    type_name:tn
    LBRACE
    record_literal_argument_list:l
    RBRACE                              {: RESULT = new RecordLiteralExpression(tn, l)                              ;:}
;

// Sequence<RecordMemberLiteral <: AST> <: AST
record_literal_argument_list_opt
::=
    record_literal_argument_list:a      {: RESULT = a                                                               ;:}
|   /* epsilon */                       {: RESULT = new Sequence()                                                  ;:}
;

// Sequence<RecordMemberLiteral <: AST> <: AST
record_literal_argument_list
::=
    IDENTIFIER:id
    EQ
    expression:e                        {: RESULT = new Sequence(new RecordMemberLiteralExpression(new Name(id), e));:}
|   record_literal_argument_list:rl
    COMMA
    IDENTIFIER:id
    EQ
    expression:e                        {: RESULT = rl.append(new RecordMemberLiteralExpression(new Name(id), e))   ;:}
;

// ProtocolLiteral <: Literal <: Expression <: AST
protocol_literal
::=
    NEW
    type_name:tn
    LBRACE
    IDENTIFIER:id2
    COLON
//  argument_list_opt:l
    record_literal_argument_list_opt:l
    RBRACE                              {: RESULT = new ProtocolLiteralExpression(tn, new Name(id2), l)             ;:}
//| NEW
//  type_name:tn
//  LBRACE
//  IDENTIFIER:id2
//  COLON
//  RBRACE
;
