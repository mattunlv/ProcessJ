delimiters "<",">"

Info() ::= <<
<! ----- This template is NEVER rendered ---- !>
This file contains all required templates for generating valid Java
source files when using the ProcessJ-JVM compiler. Note, these templates
and their attributes are rendered in the code generation phase. For
usage see: CodeGeneratorJava.java
>>

//========================================================================================
// Takes a ProcessJ file and turns it into a Java file that can be run
// again and again while maintaining the logical structure of the code
// translated by the ProcessJ-JVM compiler. The parameters below represent
// what gets pushed into the template, and, for now, these parameters
// generate the entire code for a compilable Java file.
// 1.) pathName: A region that organizes a set of related types, procedures,
//               variables, etc.
// 2.) filename: The name of a ProcessJ file.
// 3.) name: The target class for the JVM.
// 4.) body: A list of declarations generated from a ProcessJ source code.
// 5.) imports: A list of import declarations.
Compilation(pathName, fileName, name, body, version, imports) ::= <<
import java.util.*;
import processj.runtime.*;
import utilities.*;
import java.lang.reflect.Array;  
import java.util.Arrays;
import java.util.Collections;

<if(imports)><imports; separator=";\n">;<endif>

/**
 * File generated by the ProcessJ-JVM Compiler.
 * Package name '<pathName>'.
 * Code generation for '<fileName>'.
 * Target class '<name>'.
 * Java code version '<version>'.
 *
 * @author ProcessJ Group - University of Nevada, Las Vegas.
 * @since 1.2
 */
public class <name> {

	public static Object fillArray(Object o, Class c, int depth) {
        if (o.getClass().isArray()) {
            Object[] oo = (Object[]) o;
            for (int i = 0; i \< oo.length; i++) {
                if (depth != 1)
                    fillArray(oo[i], c, depth - 1);
                else {
                    try {
                        oo[i] = (Object) c.newInstance();
                    } catch (Exception e) {
                    }
                }
            }
        }
        return o;
    }
    
    <if(body)><body; separator="\n\n"><endif>
}
>>

createArray(name, newArray, type, chanType, dims, brackets) ::= <<
<name> = (<type><brackets>) fillArray(<newArray>, new <chanType>().getClass(), <dims>)
>>

//========================================================================================
// A main method definition that represents the entry point of every
// ProcessJ program and one that is called by the JVM when the program
// is run.
// 1.) class: the name of the class from which a 'main' process can be
//           created and then called by the JVM.
// 2.) name: an instance of an entry point of any ProcessJ program.
// 3.) types: the type of values associated with formal parameters.
// 4.) vars: the names of the formal parameters.
Main(class, name, types, vars) ::= <<
public static void main(<types,vars:{t,v | <t> <v>}; separator=", ">) {
	Scheduler scheduler = new Scheduler();
    PJProcess.scheduler = scheduler;
    (new <class>.<name>(<vars; separator=", ">)).schedule();
    PJProcess.scheduler.start();
}
>>

//========================================================================================
// Defines a class from which a process is created. This template
// represents the set of properties and methods that are common to
// all objects that extend the PJProcess class. The class declarations
// can include the following components, in order:
// 1.) name: the name of the class preceded by '_proc'.
// 2.) types: data types for formal parameters.
// 3.) vars: unique names for fields preceded by '_pd'.
// 4.) ltypes: data types for local parameters.
// 5.) lvars: unique names for fields preceded by '_ld'.
// 6.) methods: collection of statements that perform an operation.
// 7.) main: the entry point of the program.
// 8.) switchBlock: switch statement to jump through blocks to resume points.
// 9.) syncBody: the body (content) of synchronized method that runs/starts a process.
ProcClass(name, types, vars, ltypes, lvars, methods, main, switchBlock, syncBody) ::= <<
public static class <name> extends PJProcess {
    <! -------- Instance variables for formal parameters -------- !>
    <if(vars)><types,vars:{t,v | protected <t> <v>}; separator=";\n">;<\n><endif>
    <! -------- Instance variables for local parameters -------- !>
    <if(lvars)><ltypes,lvars:{t,v | protected <t> <v>}; separator=";\n">;<\n><endif>
    <! -------- Instance methods -------- !>
    <if(methods)><methods; separator="\n"><\n><endif>
    <! -------- Default Constructor -------- !>
    public <name>(<types,vars:{t,v | <t> <v>}; separator=", ">) {
        <! Initialize member fields !>
        <if(vars)><vars:{v | this.<v> = <v>}; separator=";\n">;<endif>
    }

    <! Synchronized run method !>
    @Override public synchronized void run() {
        <if(switchBlock)><switchBlock; separator="\n"><endif>
        <if(syncBody)><syncBody; separator="\n"><endif>
        terminate();
    }
<! Entry point of the program, e.g.
   public static void main(String[] args) { ... }
!>
<if(main)>}<\n><\n><main><else>}<endif>
>>

//========================================================================================
// An simple (or normal) invocation consists of associating the caller
// with the parameters that are used to invoked it with. This only ever
// applies to procedures that act and behave like any Java method (such
// methods are referred to by name and can be invoked at any point during
// the execution of the program) and ones that do not extend the class
// PJProcess.
// 1.) name: the name of the invoked procedure.
// 2.) vars: the names of the formal parameters.
Invocation(name, vars) ::= <<
<name>(<if(vars)><vars; separator=", "><endif>);
>>

//========================================================================================
//
// 1.) name:
// 2.) vars:
// 3.) parBlock:
// 4.) barrier:
// 5.) isPar:
InvocationProcType(name, vars, parBlock, barrier, isPar) ::= <<
(new <name>(<if(vars)><vars:{v | <v>}; separator=", "><endif>) {
    @Override public void finalize() {
        <parBlock>.decrement();
        <if(barrier)><barrier:{b | <b>.resign()}; separator=";\n">;<endif>
    }
})<if(!isPar)>.schedule();<endif>
>>

//========================================================================================
// A method definition that specifies the types and names of parameters
// (which are separated by commas and enclosed in parenthesis and are
// required by methods during invocations), the access level such as
// 'public', 'private', or 'protected', the return value, a body between
// braces {}, and the name that uniquely identifies the method.
// 1.) modifier: access level such as public, private, or protected.
// 2.) type: the data type of the value returned by the method.
// 3.) name: the name that uniquely applies and identifies the method.
// 4.) types: the type of values associated to formal parameters.
// 5.) vars: the names of the formal parameters preceded by '_ld'.
// 6.) ltypes: data types for local parameters.
// 7.) lvars: unique names for fields preceded by '_ld'.
// 8.) body: the method body enclosed between braces.
Method(modifier, type, name, types, vars, ltypes, lvars, body) ::= <<
<if(modifier)><modifier> <endif>static <type> <name>(<types,vars:{t,v | <t> <v>}; separator=", ">) {
    <! -------- Variables for local parameters -------- !>
    <if(lvars)><ltypes,lvars:{t,v | <t> <v>}; separator=";\n">;<\n><endif>
    <! The body may be an invocation or a sequence of statements !>
    <if(body)><body; separator="\n"><endif>
}
>>

//========================================================================================
// A declaration for a member variable that is defined outside of
// any method but inside the class to which it belongs.
// 1.) modifier: a keyword that defines the access of a field.
// 2.) type: a data type that determines the value a variable can contain.
// 3.) name: a qualified name for the member variable.
Field(modifier, type, name) ::= "<if(modifier)><modifier><else>public<endif> <type> <name>"

//========================================================================================
// Initializes a declaration for a variable given a type and a value.
// The declaration becomes a simple assignment statement if no type and
// no operator is specified. If a type is given, it becomes a new declaration
// in which a value may be assigned to the variable.
// 1.) type: a data type that determines the value a variable can contain.
// 2.) name: a qualified name for the variable.
// 3.) val: the value to be assigned to the variable.
// 4.) op: a build-in operator used to manipulate data and variables.
Var(type, name, val, op) ::= "<Type(type)><name><Init(val, op)>"
Type(type) ::= "<if(type)><type> <endif>"
Init(val, op) ::= "<if(val)> <if(op)><op><else>=<endif> <val>;<else>;<endif>"

//========================================================================================
// Defines a 'switch' block containing labels. These labels are used to
// route the flow of control to the resume points of different processes.
// 1.) jumps: a list of cases generated by 'SwitchCase'.
SwitchBlock(jumps) ::= <<
<if(jumps)>
switch (this.runLabel) {
    case 0: break;
    <jumps; separator="\n">
    default: break;
}
<endif>
>>

//========================================================================================
// Defines a statement in a 'switch' block with one case. The
// case evaluates to a label representing the resume point of
// a process. 
// 1.) jump: the label to restart from.
SwitchCase(jump) ::= "case <jump>: resume(<jump>); break;"

//========================================================================================
// Initializes a declaration for a 'par' statement (an object of type PJPar)
// defined in a process (an object of type PJProcess). This 'par' statement
// becomes a variable of the process in which it is declared. A reference
// to the process in which the 'par' appears and the number of processes
// found in the 'par' block are used to create a PJPar instance.
// 1.) name: the name that uniquely applies and identifies the 'par' block.
// 2.) count: the number of processes to run concurrently.
// 3.) process: the reference to the process in which the 'par' block is defined.
// 4.) body: the statements inside the 'par' block.
// 5.) jump: the label to restart from.
// 6.) barrier:
// 7.) enrollees:
ParBlock(name, count, process, body, jump, barrier, enrollees) ::= <<
final PJPar <name> = new PJPar(<count>, <process>);
<if(barrier)><barrier,enrollees:{b,e | <b>.enroll(<e>)}; separator=";\n">;<endif>

<if(body)><body; separator="\n\n"><endif>

<! Not to be scheduled again until 'data' is ready !>
if (<name>.shouldYield()) {
    this.runLabel = <jump>;
    this.yield();
    this.label(<jump>);
}<\n>
>>

//========================================================================================
// Defines an anonymous process which consist of a switch block that
// contains jump labels for resumption and yield, a synchronized body
// that runs all the statements declared inside the procedure, and a
// 'par' block defined in a procedure. Note that the process's schedule()
// method is excluded iff it is created inside a par-for. If this is
// case, then we generated code similar to that of a ProcessClass; e.g.,
// with member fields.
// 1.) switchBlock: switch statement to jump through blocks to resume points.
// 2.) syncBody: the body (content) of synchronized method that runs/starts a process.
// 3.) parBlock:
// 4.) barrier:
// 5.) ltypes: data types for local parameters that are used in a 'par-for'.
// 6.) lvars: unique names for fields preceded by '_ld' that are used in a 'par-for'.
AnonymousProcess2(switchBlock, syncBody, parBlock, barrier, ltypes, lvars, isPar) ::= <<
new PJProcess() {
    <! -------- Instance variables for local parameters -------- !>
    <if(isPar)>
    <ltypes,lvars:{t,v | protected <t> <v>}; separator=";\n">;<\n>
    PJProcess set(<ltypes,lvars:{t,v | <t> <v>}; separator=", ">) {
    	<lvars:{v | this.<v> = <v>}; separator=";\n">;
    	return this;
    }<\n>
    <endif>
    <! Synchronized run method !>
    @Override public synchronized void run() {
        <if(switchBlock)><switchBlock; separator="\n"><endif>
        <if(syncBody)><syncBody; separator="\n"><endif>
        terminate();
    }
    
    <! Finalize method !>
    @Override public void finalize() {
        <if(parBlock)><parBlock>.decrement();<endif>
        <if(barrier)><barrier:{b | <b>.resign()}; separator=";\n">;<endif>
    } <!-- The setter should be called inside the generated code for a par-for.
           Such an invocation means that the 'anonymous' process will be scheduled
           later in a separate for-loop. Otherwise, the process should be schedule
           right away. --!>
}<if(isPar)>.set(<lvars; separator=", ">)<else>.schedule();<endif>
>>

//========================================================================================
//========================================================================================
AnonymousProcess(switchBlock, syncBody, parBlock, barrier, isPar) ::= <<
new PJProcess() {
    <! Synchronized run method !>
    @Override public synchronized void run() {
        <if(switchBlock)><switchBlock; separator="\n"><endif>
        <if(syncBody)><syncBody; separator="\n"><endif>
        terminate();
    }
    
    <! Finalize method !>
    @Override public void finalize() {
        <if(parBlock)><parBlock>.decrement();<endif>
        <if(barrier)><barrier:{b | <b>.resign()}; separator=";\n">;<endif>
    }
}<if(!isPar)>.schedule();<endif>
>>

//========================================================================================
//
// 1.) type:
ChannelDecl(type) ::= "<if(type)>new <type>()<endif>"

//========================================================================================
//
// 1.) count:
BarrierDecl(count) ::= "new PJBarrier(<if(count)><count><endif>)"

//========================================================================================
//
// 1.) name:
TimerRedExpr(name) ::= "<name> = PJTimer.read();"

//========================================================================================
//
// 1.) value:
// 2.) type:
PrimitiveLiteral(value, type) ::= "<value><if(type)><type><endif>"

//========================================================================================
//
// 1.) name:
// 2.) type:
// 3.) dims:
// 4.) vals:
NewArray(name, type, init, chanInit) ::= <<
<if(name)><name> = <endif>new <type><init><if(name)>;<endif>
>>

//========================================================================================
// 1.) dims:
// 2.) vals:
NewArrayLiteral(dims, vals, dim) ::= <<
<if(dims)><dims:{dim | [<dim>]}; separator = ""><else><dim>{ <vals:{v | <v>}; separator=","> }<endif>
>>

//========================================================================================
//
// 1.) name:
// 2.) index:
ArrayAccessExpr(name, index) ::= "<name>[<index>]"

//========================================================================================
//
// 1.) name:
// 2.) delay:
// 3.) resume0:
TimeoutStat(name, delay, resume0) ::= <<
<name> = new PJTimer(this, <delay>);
try {
    <name>.start();
    this.setNotReady();
    this.runLabel = <resume0>;
    this.yield();
} catch (InterruptedException e) {
    System.out.println("An Interrupted exception occurred for a timer!");
}
label(<resume0>);
>>

//========================================================================================
//
// 1.) name:
// 2.) delay:
TimeoutStatCase(name, delay) ::= <<
<name> = new PJTimer(this, <delay>);
>>

//========================================================================================
//
// 1.) block:
BlockRV(block) ::= <<
<if(block)><block; separator="\n"><endif>
>>

//========================================================================================
//
// 1.) chaName: name of the write channel-end.
// 2.) resume0:
// 3.) resume1:
ChanWriteStat(chanName, writeExpr, resume0) ::= <<
<chanName>.write(this, <writeExpr>);
this.runLabel = <resume0>;
this.yield();

label(<resume0>);<!-- remove 'line-feed' --!>
>>

//========================================================================================
//
// 1.) chaName: name of the write channel-end.
// 2.) resume0:
// 3.) resume1:
ChannelReadExpr(chanName, lhs, type, op, resume0, resume1, extendRv) ::= <<
if (!<chanName>.isReadyToRead(this)) {
    this.runLabel = <resume0>;
    this.yield();
}

label(<resume0>);
<if(extendRv)> // Do we have a rendezvous?
<lhs> <op> <chanName>.preReadRendezvous(this);
<extendRv>
<chanName>.postReadRendezvous(this);
<else>
<if(lhs)><lhs> <op> <if(type)>(<type>) <endif><chanName>.read(this);
<else><chanName>.read(this);
<endif>
<endif>
this.runLabel = <resume1>;
this.yield();

label(<resume1>);<!-- remove 'line-feed' --!>
>>

//========================================================================================
//
// 1.) chanName:
// 2.) resume0:
// 3.) resume1:
// 4.) resume2:
ChannelOne2Many(chanName, lhs, op, resume0, resume1, resume2, extendRv) ::= <<
if (!<chanName>.claimRead(this)) {
    this.runLabel = <resume0>;
    this.yield();
}
label(<resume0>);

if (!<chanName>.isReadyToRead(this)) {
    this.runLabel = <resume1>;
    this.yield();
}

label(<resume1>);
<if(extendRv)> // Do we have a rendezvous?
<lhs> <op> <chanName>.preReadRendezvous(this);
<extendRv>
<chanName>.postReadRendezvous(this);
<else>
<if(lhs)><lhs> <op> <chanName>.read(this);
<else><chanName>.read(this);
<endif>
<endif>
this.runLabel = <resume2>;

<chanName>.unclaimRead();

this.yield();
label(<resume2>);
>>

//========================================================================================
//
// 1.) chanName:
// 2.) writeExpr:
// 3.) resume0:
// 4.) resume1:
ChannelMany2One(chanName, writeExpr, resume0, resume1) ::= <<
if (!<chanName>.claimWrite(this)) {
    this.runLabel = <resume0>;
    this.yield();
}
label(<resume0>);

<chanName>.write(this, <writeExpr>);
this.runLabel = <resume1>;

this.yield();
label(<resume1>);

<chanName>.unclaimWrite();<\n>
>>

//========================================================================================
//
// 1.) expr:
// 2.) thenPart:
// 3.) elsePart:
IfStat(expr, thenPart, elsePart) ::= <<
if (<expr>) {
    <thenPart; separator="\n">
}<if(elsePart)> else {
    <elsePart; separator="\n">
}<endif>
>>

//========================================================================================
//
// 1.) name:
BreakStat(name) ::= <<
<if(name)><name><else>break;<endif>
>>

//========================================================================================
//
// 1.) label:
SwitchLabel(label, tag) ::= <<
<if(label)>case <label><else>default<endif>
>>

//========================================================================================
//
// 1.) labels:
// 2.) stats:
SwitchGroup(labels, stats) ::= <<
<labels:{l | <l>:}; separator="\n">
    <stats; separator="\n">
>>

//========================================================================================
//
// 1.) expr:
// 2.) block:
SwitchStat(expr, block, tag) ::= <<
switch(<expr><if(tag)>.tag<endif>) {
<block; separator="\n">
}
>>

//========================================================================================
//
// 1.) operand:
// 2.) op:
UnaryPostExpr(operand, op) ::= "<if(operand)><operand><op><endif>;"

//========================================================================================
//
// 1.) operand:
// 2.) op:
UnaryPreExpr(operand, op) ::= "<if(operand)><op><operand><endif>;"

//========================================================================================
//
// 1.) type:
// 2.) expr:
CastExpr(type, expr) ::= "<if(type)>((<type>) (<expr>))<endif>"

//========================================================================================
//
// 1.) lhs:
// 2.) rhs:
// 3.) op:
BinaryExpr(lhs, rhs, op) ::= <<
<lhs> <op> <rhs>
>>

//========================================================================================
//
// 1.) package:
// 2.) file
Import(package, file) ::= "import <package><if(file)>.<file><endif>"

//========================================================================================
//
// 1.) modifier: access level such as public, private, or protected.
// 2.) name: the name that uniquely applies and identifies the record.
// 3.) types:
// 4.) vars:
// 5.) extend:
RecordType(modifiers, name, types, vars, extend) ::= <<
<if(modifiers)><modifiers; separator=" "> <else>protected <endif>interface I_<name> { }

<if(modifiers)><modifiers; separator=" "> <else>protected <endif>static class <name> extends PJRecord implements <extend:{e | I_<e>}; separator=", "> {
    <! -------- Member variables -------- !>
    <if(vars)><types,vars:{t,v | public <t> <v>}; separator=";\n">;<\n><endif>
    <! -------- Default Constructor -------- !>
    public <name>(<types,vars:{t,v | <t> <v>}; separator=", ">) {
        <! Initialize member fields !>
        <if(vars)><vars:{v | this.<v> = <v>}; separator=";\n">;<endif>
    }
    
    @Override public String toString() {
    	return "*" + toString(null, 0);
    }
}
>>

//========================================================================================
//
// 1.) type:
// 2.) vals:
RecordLiteral(type, vals) ::= <<
new <type>(<vals; separator=", ">)
>>

//========================================================================================
//
// 1.) name:
// 3.) member:
RecordAccessor(name, member) ::= "<if(name)><name>.<member><endif>"

//========================================================================================
//
// 1.) modifier: access level such as public, private, or protected.
// 2.) name: the name that uniquely applies and identifies the protocol.
// 3.) body:
ProtocolClass(modifiers, name, body) ::= <<
<if(modifiers)><modifiers; separator=" "> <else>protected <endif>static class <name> {
    <body; separator="\n\n">
}
>>

//========================================================================================
//
// 1.) modifier:
// 2.) name:
// 3.) types:
// 4.) vars:
ProtocolType(modifier, name, types, vars) ::= <<
<if(modifier)><modifier> <else>protected <endif>static class <name> extends PJProtocolCase {
    <! -------- Member variables -------- !>
    <if(vars)><types,vars:{t,v | public <t> <v>}; separator=";\n">;<\n><endif>
    <! -------- Default Constructor -------- !>
    public <name>(<types,vars:{t,v | <t> <v>}; separator=", ">) {
        <! Initialize member fields !>
        <if(vars)><vars:{v | this.<v> = <v>}; separator=";\n">;<endif>
        this.tag = "<name>";
    }
}
>>

//========================================================================================
//
// 1.) modifier:
// 2.) name:
// 3.) types:
// 4.) vars:
ProtocolCase(modifier, name, types, vars) ::= <<
<if(modifier)><modifier> <else>protected <endif>static class <name> extends PJProtocolCase {
    <! -------- Member variables -------- !>
    <if(vars)><types,vars:{t,v | public <t> <v>}; separator=";\n">;<\n><endif>
    <! -------- Default Constructor -------- !>
    public <name>(<types,vars:{t,v | <t> <v>}; separator=", ">) {
        <! Initialize member fields !>
        <if(vars)><vars:{v | this.<v> = <v>}; separator=";\n">;<endif>
        this.tag = "<name>";
    }
}
>>

//========================================================================================
//
// 1.) name:
// 2.) tag:
// 3.) vals:
ProtocolLiteral(type, tag, vals) ::= <<
new <type>.<tag>(<if(vals)><vals; separator=", "><endif>)
>>

//========================================================================================
//
// 1.) protocName:
// 2.) tag:
// 3.) var:
// 4.) member:
ProtocolAccess(protocName, tag, var, member) ::= <<
<if(protocName)>(((<protocName>.<tag>) <var>).<member>)<endif>
>>

//========================================================================================
//
// 1.) barrier:
// 2.) resume0:
SyncStat(barrier, resume0) ::= <<
<barrier>.sync(this);
this.runLabel = <resume0>;
this.yield();
label(<resume0>);
>>

//========================================================================================
//
// 1) expr:
// 2) body:
WhileStat(expr, body) ::= <<
while (<expr>) {
    <if(body)><body; separator="\n"><endif>
}
>>

//========================================================================================
//
// 1) expr:
// 2) stats:
DoStat(expr, body) ::= <<
do {
    <if(body)><body; separator="\n"><endif>
} while (<expr>);
>>

//========================================================================================
//
// 1) init:
// 2) expr:
// 3) incr:
// 4) stats:
ForStat(init, expr, incr, stats) ::= <<
for (<init>; <expr>; <incr>) {
	<if(stats)><stats; separator="\n"><endif>
}
>>

//========================================================================================
//
// 1.) init:
// 2.) expr:
// 3.) incr:
// 4.) stats:
// 5.) name:
// 6.) count:
// 7.) jump:
// 8.) barrier:
ParForStat(init, expr, incr, stats, name, jump, barrier) ::= <<
final PJPar <name> = new PJPar(0, this);
ArrayList\<PJProcess> processes = new ArrayList\<PJProcess>();
int count = 0;

for (<init>; <expr>; <incr>) {
    ++count;
    <if(stats)><stats:{st | processes.add(<st>)}; separator=";\n">;<endif>
}

<name>.setProcessCount(count);
<if(barrier)><barrier:{b | <b>.enroll(count)}; separator=";\n">;<endif>

for (PJProcess p : processes)
    p.schedule();

this.setNotReady();
this.runLabel = <jump>;
this.yield();
label(<jump>);
>>

//========================================================================================
//
// 1.) number:
// 2.) guardExpr:
// 3.) stats:
AltCase(number, guardExpr, stats, dynamicAlt) ::= <<
case <number>:
    <if(dynamicAlt)><dynamicAlt><endif>
    <guardExpr>
    <if(stats)><stats; separator="\n"><endif>
    break;
>>

//========================================================================================
//
// 1.) alt:
// 2.) count:
// 3.) timerLocals:
// 4.) initBooleanGuards:
// 5.) initGuards:
// 6.) bguards:
// 7.) guards:
// 8.) jump:
// 9.) cases:
// 10.) index:
AltStat(alt, count, timerLocals, initBooleanGuards, initGuards, bguards, guards, jump, cases, index, readyID) ::= <<
<alt> = new PJAlt(<count>, this);
<timerLocals>
<initBooleanGuards>
<initGuards>
boolean ready<readyID> = <alt>.setGuards(<bguards>, <guards>);

if (!ready<readyID>) {
    System.out.println("RuntimeError: One of the boolean pre-guards must be true!");
    System.exit(1);
}

this.setNotReady();
<index> = <alt>.enable();
this.runLabel = <jump>;
this.yield();

label(<jump>);
int selected<readyID> = <alt>.disable(<index>);

switch(selected<readyID>) {
    <cases; separator="\n">
    default:
        break;
}
>>

//========================================================================================
//
// 1.) locals:
// 2.) constants:
BooleanGuards(locals, constants, readyID) ::= <<
<if(locals)><locals; separator="\n"><endif>
<if(constants)>Boolean[] __booleanGuards<readyID> = { <constants; separator=", "> };
List\<Boolean> booleanGuards<readyID> = Arrays.asList(__booleanGuards<readyID>);
<endif>
>>

//========================================================================================
//
// 1.) guards:
ObjectGuards(guards, readyID) ::= <<
<if(guards)>Object[] __objectGuards<readyID> = { <guards; separator=", "> };
List\<Object> objectGuards<readyID> = Arrays.asList(__objectGuards<readyID>);
<endif>
>>

//========================================================================================
//========================================================================================
//========================================================================================
//========================================================================================
//========================================================================================
//
// 1.) alt:
// 2.) initGuards:
// 3.) objectGuards:
// 4.) bguards:
// 5.) guards:
// 6.) jump:
// 7.) cases:
// 8.) index:
ReplicatedAltStat(alt, initGuards, objectGuards, bguards, guards, initForStmt, jump, cases, index, readyID) ::= <<
<alt> = new PJAlt(this);
<initGuards>
List\<AltGuard> dynamicAltGuards = new ArrayList\<>();

<if(objectGuards)>repAltObjectGuards.add(<objectGuards>);<endif>
<if(initForStmt)><initForStmt; separator="\n"><endif>
boolean ready<readyID> = <alt>.setGuards(<bguards>, <guards>);
<alt>.setDynamicAlts(dynamicAltGuards);

if (!ready<readyID>) {
    System.out.println("RuntimeError: One of the boolean pre-guards must be true!");
    System.exit(1);
}

this.setNotReady();
<index> = <alt>.enable();
this.runLabel = <jump>;
this.yield();

label(<jump>);
int selected = <alt>.disable(<index>);
AltGuard selectedGuard = <alt>.getDynamicAlts(selected);
selected = selectedGuard.getAltCaseNumber();

switch(selected) {
    <cases; separator="\n">
    default:
        break;
}
>>

//
// 1.) indexSet
RepLocalVars(indexSet) ::= <<
<indexSet:{v | <v> = selectedGuard.getIndex();}; separator="\n">
>>

//
// 1.) locals:
RepAltGuards(locals) ::= <<
<if(locals)><locals; separator="\n"><endif>
List\<Boolean> repAltBooleanGuards = new ArrayList\<>();
List\<Object> repAltObjectGuards = new ArrayList\<>();
>>

//
// 1.) size:
// 2.) indexSet:
// 3.) altCase:
RepAltIndexSet(size, indexSet, altCase, varID) ::= <<
AltGuard repAltGuard<varID> = new AltGuard(<size>);
repAltGuard<varID>.addIndex(<indexSet; separator=", ">);
repAltGuard<varID>.addAltCaseNumber(<altCase>);
dynamicAltGuards.add(repAltGuard<varID>); // add altCaseIndex
>>

//
// 1.) objectGuards:
// 2.) objectValue:
// 3.) booleanGuards:
// 4.) booleanValue:
RepAltObjectGuards(objectGuards, objectValue,booleanGuards,booleanValue) ::= <<
<objectGuards>.add(<objectValue>);
<booleanGuards>.add(<booleanValue>);
>>


//========================================================================================
//========================================================================================
//========================================================================================
//========================================================================================
//========================================================================================

//========================================================================================
//
// 1.) timers:
TimerLocals(timers) ::= <<
<if(timers)><timers; separator="\n"><endif>
>>

//========================================================================================
//
// 1.) type:
// 2.) var:
ConstantDecl(type, var) ::= "public static final <type> <var>"

//========================================================================================
//
// 1.) expr:
ReturnStat(expr) ::= "<if(expr)>return <expr>;<endif>"

//========================================================================================
// 1.) name:
ContinueStat(name) ::= "<if(name)>continue <name><else>continue<endif>;"

//========================================================================================
//
// 1.) name:
// 2.) var:
InvocationIgnore(name, var) ::= "<name>(<var>);"

//========================================================================================
//
// 1.) name:
// 2.) type:
RecordExtend(name, type) ::= "<name> instanceof <type>"

//========================================================================================
//
// 1.) str1:
// 2.) str2:
StringCompare(str1, str2) ::= "<str1>.equals(<str2>)"

//========================================================================================
//
// 1.) expr:
// 2.) trueBranch:
// 3.) falseBranch:
Ternary(expr, trueBranch, falseBranch) ::= "<expr> ? <trueBranch> : <falseBranch>"